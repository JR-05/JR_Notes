# 前言

### 为什么在传统的SQL数据库的背景下会出现NoSql数据库

在90年代，一个网站的访问路一般都不大，用单个数据库完全可以轻松应付。

但随着互联网时代的发展，简单的系统架构已无力承受大流量的访问，网站架构也日益复杂，目的就是解决大流量的访问。

![简单系统架构](photo\简单系统架构.bmp)

在《我在淘宝这十年》一书中提到，早期的网站的架构也是从简单到LAMP架构模式演变到使用**Oracle、搜索引擎、分库分表，主从库**来减缓对数据库的压力，要知道即使是在牛逼的数据库面对每日几千万的访问量也是难以支撑的，所以避免多次对数据库进行访问是提高系统性能的手段之一。

![加入缓存的系统架构](photo\加入缓存的系统架构.bmp)

并且有些业务当中往往在需要重复在访问数据库中的同个字段数据，因为这种情况，那么我们是否可以将这个字段数据提取出来放在缓存里，访问时不必再次去从数据库中拿而是从缓存中拿。

NoSQL一般为内存数据库，其优点是**性能高、读写数据快**，正因为这个原因所以非常适合作为缓存，而其中Redis就是当中的明星角色。

​	

### NoSQL数据库的四大分类

- KV键值，代表产品有：Memecache、redis
- 文档型数据库，代表产品有：CouchDB、MongoDB
- 列存储数据库，代表产品有：Cassandra、HBase
- 图关系数据库，代表产品有：Neo4J、InfoGrid

根据数据类型或关系选择合适的NoSQL数据库。



### Redis

#### 介绍

​	Redis:REmote DIctionary Server(远程字典服务器)。

​	是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内	存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。

#### Redis的优点

​	Redis 与其他 key - value 缓存产品有以下三个特点：

1. Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
2. Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储
3. Redis支持数据的备份，即master-slave模式的数据备份

#### Linux环境下载Redis

由于企业里面做Redis开发，99%都是Linux版的运用和安装，几乎不会涉及到Windows版	

##### 注意

在make编译时之前需要Linux系统需要安装gcc环境，可通过yum联网下载配置`yum install gcc-c++`
**下载地址：**<http://redis.io/download>，下载最新稳定版本。

1. **下载>>>解压>>>编译**

   ```shell
   [root@localhost]# wget http://download.redis.io/releases/redis-2.8.17.tar.gz#联网下载
   [root@localhost]# tar xzf redis-2.8.17.tar.gz						#解压到当前目录
   [root@localhost]# cd redis-2.8.17										#进入解压目录
   [root@localhost redis]# make												#编译
   ```

2. **添加到环境变量**

   	为了使用方便，我们需要将这个几个文件加到/usr/local/bin目录下去。这个目录在Path下面的话，就可以直接执行这几个命令了。

   ```shell
   [root@localhost redis]# make install
   cd src && make install
   ```

3. **运行redis服务**

    make install完后/usr/local/bin目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下（也就是解压目录xi）：

   - 使用默认配置文件

     ```shell
     $ cd src
     $ ./redis-server
     ```


   - 使用指定配置文件

     ```shell
     $ cd src
     $ ./redis-server redis.conf配置文件路径
     ```


4. **启动Redis客户端**

    类似于启动Mysql服务后，需要有一个客户端与服务端进行交互。

    ```shell
    $ cd src			#进入安装目录
    $ ./redis-cli		#启动redis客户端
    redis> set foo bar	#添加数据
    OK					#操作提示
    redis> get foo		#获取数据
    "bar"				#数据
    ```

    **用法**

    redis-cli [OPTIONS]\[cmd [arg [arg ...]]

    -h <主机ip>，默认是127.0.0.1

    -p <端口>，默认是6379

    -a <密码>，如果redis加锁，需要传递密码

    --help，显示帮助信息

5. **关闭服务**

   - 关闭单实例运行客户端连接的redis服务

   ```shell
   $ redis-cli shutdown
   ```

   - 关闭指定端口上运行的客户端连接的redis服务

   ```shell
   $ redis-cli -p 6379 shutdown
   ```

6. **退出**

   ```shell
   exit
   ```


#### Redis安装目录

​	在Linux下默认的安装目录在usr/local/bin下，其中reids的安装目录主要有：

[^redis-benchmark]: 性能测试工具，可以在自己本子运行，看看自己本子性能如何
[^redis-server]: Redis服务启动命令
[^redis-cli]: 客户端，操作入口
[^redis-sentinel]: redis集群使用
[^redis-check-aof]: 修复有问题的AOF文件，rdb和aof后面讲
[^redis-check-dump]: 修复有问题的dump.rdb文件



### CPA理论

​	关系型数据库遵循的是ACID规则，即A（原子性）、C（一致性）、I（隔离性）、D（持久性）。

​	那么在非关系型数据库中当然也有自己的规则，那就是CAP，即C（强一致性）、P（可用性）、A（分布容错性）。
​	不过在关系型数据库中必须遵行ACID所有规则，但在非关系型数据库中却只能进行3选2，也就是只能满足CA、CP、AP。
​	CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。

>一些分布式系统对CPA的选择

 CA ：传统Oracle数据库


 AP：大多数网站架构的选择

 CP：Redis、Mongodb

**分析**

​	分布式架构的时候必须做出取舍。一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性（实现强一致性必定会损耗系统整体性能）。因此牺牲C换取P，这是目前分布式数据库产品的方向。

而Redis往往作为缓存数据库，所以对于数据安全性比较低，从而导致在数据的一致性也相对较差一些。
​	但对于传统Oracle数据库而言，作为一款磁盘存储数据库，对于每一次写操作都保存在磁盘当中，所以数据的安全性和一致性比较高。
​	对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地。
​	比如数据库事务一致性需求 。
　　很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性（对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的）。
　　

> Base

​	BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。
BASE其实是下面三个术语的缩写：	

 	   1.基本可用（Basically Available）
   	   2.软状态（Soft state）
 	   3.最终一致（Eventually consistent）
​	它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法



> 分布式和集群的概念

- 分布式：不同的多台服务器上面部署**不同的服务模块（工程）**，他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。

- 集群：不同的多台服务器上面部署**相同的服务模块**，通过分布式调度软件进行统一的调度，对外提供服务和访问。



### 基本知识

1. Redis默认有16个数据库，默认使用零号数据库

2. **select**命令切换数据库，如：

   ```redis
   select 0			#切换到零号数据库
   ```

3. **dbsize**命令查看当前数据库的key的数量

   ![dbsize](photo\dbsize.bmp)

4. **flushdb**命令清空当前库数据，包括key和value

   ![flushdb](photo\flushdb.bmp)

5. **flushall**命令删除所有库数据，包括key和value，小心使用

![flushall](photo\flushall.bmp)



# 配置文件解析

### units（单位）

![配置文件解析_unite](photo\配置文件解析_unite.bmp)

1 . 配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit。
2 . 对大小写不敏感，也就是1GB与1gb和1gB都一样。



### INCLUDES（包含）

![配置文件解析_INCLUDES](photo\配置文件解析_INCLUDES.bmp)

类似于在Spring中为主配置文件包含其它配置文件，通过    `include redis配置文件文件位置`    进行包含。



### GENERAL（通用）

![配置文件解析_GENERAL](photo\配置文件解析_GENERAL.bmp)

  主要配置设置有：

[^daemonize]: redis服务是否以后台方式启动
[^pidfile]: 保存记录进程pid日志文件
[^port]: redis服务端口
[^tcp-backlog]: 在高并发环境下你需要一个高backlog值来避免慢客户端连接问题
[^timeout]: 配置客户端与服务端连接空闲超时时间，如果客户端在这段时间与服务端无任何响应将断开连接。设置0表示无限制空闲时间，一致连着。
[^bind]: 默认的bind 接口是127.0.0.1，也就是本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接， 这样可以避免将redis服务暴露于危险的网络环境中，防止一些不安全的人随随便便通过远程 连接到redis服务。 如果bind选项为空的话，那会接受所有来自于可用网络接口的连接
[^tcp-keepalive]: 设置每隔几秒发送心跳包检测连接是否正常。设置0表示不进行检测
[^loglevel]: 设置日志过滤级别。越往下级别越高，输出信息越少，可选有：

1. debug
2. verbose
3. notice
4. warning

[^logfile]: 输出日志文件保存位置
[^syslog-enabled]: 是否把日志输出到syslog中
[^syslog-ident]: 指定syslog里的日志标志
[^syslog-facility]: 指定syslog设备，值可以是USER或LOCAL0-LOCAL7
[^databases]: 设置数据库数量，默认为16



### SNAPSHOTTING（快照）





### REPLICATION（复制）



### SECURITY（安全）

![配置文件解析_SECURITY](photo\配置文件解析_SECURITY.bmp)

​	Redis的安全说明，若设置redis密码的话，那么在操作redis之前需要进行密码验证。

**密码设置**

```shell
config set requirepass "密码"
```

**密码验证**

```shell
auth 密码
```

![安全设置](photo\安全设置.bmp)



### LIMITS（限制）

![配置文件解析_LIMITS](E:\笔记\Redis\photo\配置文件解析_LIMITS.bmp)

设置客户端连接的限制和Redis在内存中数据量的大小与内存数据移除的策略。。。主要有以下四种配置。

[^maxclients]: 设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端，如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。
[^maxmemory]: 设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素
[^maxmemory-policy]: 数据移除策略，有以下几种方式：

1. volatile-lru：使用LRU算法移除key，只对设置了过期时间的键
2. allkeys-lru：使用LRU算法移除key
3. volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键
4. allkeys-random：移除随机的key
5. volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key
6. noeviction：不进行移除。针对写操作，只是返回错误信息

[^maxmemory-samples]: 设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个





### APPEND ONLY MODE（追加）





# 常用五大数据类型

> string（字符串）

string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。
string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。
string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M。



> hash（哈希，类似java里的Map）

Hash（哈希）
Redis hash 是一个键值对集合。
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。
类似Java里面的Map<String,Object>



> list（列表）

List（列表）
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个链表。




> set（集合）

Set（集合）
Redis的Set是string类型的无序集合。它是通过HashTable实现实现的。



> zset(sorted set：有序集合)

zset(sorted set：有序集合)
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。
redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。



# 数据类型操作命令

### 完整数据类型操作命令

http://redisdoc.com/

### 常见数据类型操作命令

#### key（键）

> keys （查询当前库所有key名）

- 查询所有

  ```shell
  keys *
  ```

  ![keys1](photo\keys1.bmp)

- 匹配查询（类似SQL查询中使用'?'占位符查询）

  ```shell
  keys key?
  ```

  ![keys2](photo\keys2.bmp)



> exists （判断是否存在某个key）

```sshell
exists key名
```



![exists](photo\exists.bmp)



> move（将某个key和value剪切到指定库）

```shell
move key名 db索引
```

![move](photo\move.bmp)



> type （查看key是什么类型）

```shell
type key名
```

![type](photo\type.bmp)



> expire（给key设置过期时间）

```shell
expire key名 秒钟
```

![expire](photo\expire.bmp)

到期后，key和value都会从内存中移除



> ttl（查看key还有多少秒过期）

```shell
ttl key名
```

![ttl](photo\ttl.bmp)

**返回值表示**

[^-1]: 表示永不过期
[^-2]: 表示已过期
[^≥0]: 剩余过期时间



#### string（字符串）

##### 增删改查

- set（设值）

  ```shell
  set key名 value值
  ```

  若之前存在该key名，那么将覆盖原来值

- get（查询指定key名的value值）

  ```shell
  get key名
  ```

- del（删除指定key名的数据）

  ```shell
  del key名
  ```

- append（在指定key名对应的string数据后面追加数据，成功返回字符串长度）

  ```shell
  append key名 追加数据
  ```

- strlen（查询指定key名数据的字符串长度）

  ```shell
  strlen key名
  ```


##### 数字字符加减

- incr（+1）

  ```shell
  incr key名
  ```

- decr（-1）

  ```shell
  decr key名
  ```

- incrby（+X）

  ```shell
  incrby key名 加数
  ```

- decrby（-X）

  ```shell
  decrby key名 减数
  ```

**注意：一定得是数字字符串数据才能加减**



##### 范围操作数据

- getrange（获取指定范围字符串）

  ```shell
  getrange key名 起始位置 结尾位置
  ```

  ![getrange](photo\getrange.bmp)

- setrange（在指定位置开始插入数据）

  ```shell
  setrange key名 插入位置 插入数据
  ```

  ![setrange](photo\setrange.bmp)



##### 多数据操作

- mset（同时设多个值）

  ```shell
  mset key1名 value1值 key2名 value2值
  ```

  ![mset](photo\mset.bmp)



- mget（同时获取多个值）

  ```shell
  mget key1名 key2名
  ```

  ![mget](photo\mget.bmp)



##### 多重操作

- setex（设值的同时设置过期时间）

  ```shell
  setex key名 过期时间（秒） value值
  ```

  ![setex](photo\setex.bmp)

- setnx（设值之前会判断是否已存在该key，已存在将设值失败）

  ```shell
  setnx key名 value值
  ```

- msetex（同理，设多值之前会先判断是否已存在key）

  ```shell
  msetex key1名 value1值 key2名 value2值
  ```



##### 先后操作

- getset（先get然后立即set）

  ```shell
  getset key名 覆盖value值
  ```

  ![getset](photo\getset.bmp)



#### list（列表）

##### 查

- lindex（查询指定索引的值）

  ```shell
  lindex key名 索引
  ```

  ![lindex](photo\lindex.bmp)

- lrange（查询指定范围的列表数据）

  ```shell
  lrange key名 起始位置 结尾位置
  ```

  ![lrange](photo\lrange.bmp)

  -1：表示无穷大，也就是0 -1将查询所有列表数据

- llen（查询列表数据量）

  ```shell
  llen key名
  ```

  ![llen](photo\llen.bmp)


##### 增

- lpush（向左追加数据）

  ![lpush](photo\lpush.bmp)

- rpush（向右追加数据）

  ![rpush](photo\rpush.bmp)

- linsert（指定某数据前或后插入）

  ```shell
  linsert key名 before|after 位置相对数据 插入数据
  ```

  ![linsert](photo\linsert.bmp)





**注意对应方向：插入是从左向右，查询是从上往下**

##### 删

成功返回删除数据值

- lpop（删除左边第一个数据）

  ```shell
  lpop key名
  ```

  ![lpop](photo\lpop.bmp)

- rpop（删除右边第一个数据）

  ![rpop](E:\笔记\Redis\photo\rpop.bmp)

- lrem （删除多个value）

  ```shell
  lrem key名 删除数量 删除value值
  ```

  ![lrem](photo\lrem.bmp)

##### 改

-  ltrim（截取指定范围数据）

  ```shell
  ltrim key名 起始位置 结尾位置
  ```

  ![ltrim](photo\ltrim.bmp)

- lset（指定位置修改数据）

  ```shell
  lset key名 位置 value值
  ```

  ![lset](photo\lset.bmp)



##### 多重操作

- rpoplpush（移除列表的最后一个元素，并将该元素添加到另一个列表并返回）

  ![rpoplpush](photo\rpoplpush.bmp)



#### set（集合）



#### hash（哈希）



#### sorted set（有序集合）



