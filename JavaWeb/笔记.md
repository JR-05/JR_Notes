# 互联网常见协议

​       **协议**         **工作端口**

- http           80         
- smtp         25
- pop3         110
- ftp              23
- https          443

# Tomcat启动失败原因

- JAVA_HOME环境未配置

由于Tomcat依赖于java环境，所以Tomcat找不到JDK环境，就启动不了Tomcat

- 端口被占用
- Catalina_home环境变量的设置问题

Catalina_home环境变量：配置Tomcat位置

startup.bat（启动Tomcat），首先会在环境变量中启动Catalina_home配置中的Tomcat。所以，如果你配置了Catalina_home的话，在本地盘中有多个Tomcat服务器，假若你运行的是C盘中的startup.bat，但你Catalina_home配的是D盘的Tomcat，则它启动的D盘的Tomcat。



# Tomcat目录结构

- bin                            存放启动和关闭Tomcat等的脚本文件
- conf                          存放Tomcat的各种配置文件(如配置Tomcat运行端口的server.xml文件)
- lib                              存放Tomcat支持的jar包
- logs                           存放Tomcat的日志文件（如Tomcat黑窗口中的输出信息）
- temp                         存放Tomcat运行是产生的临时文件。对于WEB开发者来说不必关心，只供Tomcat服务器开发者有用
- webapps                  存放Web开发的应用，即供外界访问的Web资源存放目录
- work                         Tomcat的工作目录，如Tomcat在运行中将JSP转换成Servlet代码，这些Servlet代码就存放在工作目录中



# WEB应用的组成结构

- mail					WEB应用所在目录
- html,jsp,css,js文件等            这些文件一般存在WEB应用根目录下，根目录下的文件外界可以直接访问
- WEB-INF                                java类，jar包，web应用的配置文件存在这个目录下，该目录下的文件外界无法直接访问，有web服务器负责调用
- WEB-INF/classes                  java类
- WEB-INF/lib                          jar包
- WEB-INF/web.xml               WEB应用配置文件

# 虚拟目录的映射

**WEB应用:**  WEB应用程序指供浏览器访问的程序，通常称为WEB应用

**WEB目录：**存放WEB应用程序的目录，称之为WEB目录

**虚拟目录的映射:** WEB应用开发好后，若想供外界访问，需要将WEB目录交给WEB服务器管理，这个过程称之为虚拟目录的映射。



### 虚拟目录映射方式

- 在conf\server.xml目录下配置<Context/>

```
<Context path="/外界访问的虚拟目录"  docBase="WEB目录"/>
```

**特点**：加入WEB服务器（Tomcat）在C盘，而开发的工作环境目录在D盘，那么就可以通过这种方式，直接将D盘的WEB应用目录映射到Tomcat中。**但需要重启Tomcat。**

- 在conf\Catalina\localhost下创建**文件名.XML**，在XML文件下配置<Context/>

1. 文件名：外界访问的虚拟目录
2. 文件下配置

**技巧：**如果需要进行多级的虚拟目录（即：localhost:8080**/a/b/c**）,那么可通过取文件名的时候在每级目录名用”#“进行分割

如：创建一个多级目录localhost:8080**/a/b/c**，则文件名就是：a#b#c.xml

**特点**：加入WEB服务器（Tomcat）在C盘，而开发的工作环境目录在D盘，那么就可以通过这种方式，直接将D盘的WEB应用目录映射到Tomcat中。**无需重启Tomcat。**

```
<Context docBase="WEB目录"/>
```

- 直接将WEB应用放在webapps下，Tomcat会自动映射

**特点**：**方便快捷。无需重启Tomcat。**但会只能跟随Tomcat服务器目录，所以如果Tomcat放在C盘，则会消耗C盘空间。



# 配置虚拟主机

### 简介

在一个tomcat服务器中可以放置多个网站，所谓配置虚拟主机，就是在tomcat服务器中放置一个网站

### 方法

使用服务器配置文件（server.xml）中用户Host元素标签进行配置。

```
<Host name="主机名" appBase="站点目录"/>
```

配置完虚拟主机之后在配置该站点的WEB应用。

```
<Host name="主机名" appBase="站点目录">
<Context path="虚拟目录" docBase="WEB应用实际目录" />
<Host/>
```



# 浏览器访问Web资源的流程

![浏览器访问Web资源的流程图](E:\笔记\JavaWeb\photo\浏览器访问Web资源的流程图.png)

### 主机名作用

1. 通过主机名搜索DNS服务器查找服务器IP
2. 在发送HTTP请求中携带主机名，确定访问的站点



# WEB应用打包

### 命令

```
jar -cvf 包名.war WEB应用目录
```

###jar命令参数

![jar参数](E:\笔记\JavaWeb\photo\jar参数.bmp)

### 打包

![WEB应用打包](E:\笔记\JavaWeb\photo\WEB应用打包.bmp)

将war包直接放在tomcat的默认虚拟主机目录（webapps）下，tomcat会自动识别解压.

# Tomcat体系架构

1. Tomcat启动时会启动一个Service（服务）

2. 这个服务会启动多个Connector(连接器),不同连接器处理不同请求。如处理HTTP，HTTPS（加密请求）。。。

3. 连接器处理请求时会找Tomcat引擎（Engine）

4. Engine会找请求的虚拟主机目录

5. 虚拟主机就找请求的WEB应用

6. WEB应用找到请求对应的WEB资源

   ![img](file:///E:/%E7%AC%94%E8%AE%B0/JavaWeb/photo/Tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.bmp?lastModify=1524404941)

# 配置加密连接器

- 创建数字证书

​       **Java命令**

```
keytool -genkey -alias tomcat -keyalg RSA
```

![创建数字证书](E:\笔记\JavaWeb\photo\创建数字证书.bmp)

- 在server.xml配置加密连接器

```
    <Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
clientAuth="false" sslProtocol="TLS" 
keystoreFile="conf/.keystore"     //数字证书目录
keystorePass="数字证书密钥库密码"  
    />

```

- 通过HTTPS连接器访问WEB应用

![用加密连接器访问WEB应用](E:\笔记\JavaWeb\photo\用加密连接器访问WEB应用.bmp)



# HTTP协议

### 简介

HTTP(Hyper Text Transfer Protocol)超文本传输协议。它是一种请求响应式协议，客户端在与服务端建立连接后，就可以想服务器端发送请求，这种请求被称为**HTTP请求**，服务器端接收到请求后会做出响应，称为**HTTP响应**。

### HTTP1.0和HTTP1.1的区别

一个完整的HTTP请求有四个步骤。1.建立连接→2.发送请求信息→3.响应请求信息→4.关闭连接

HTTP1.0：客户端与服务器建立连接之后，中间只能处理一次请求和发送一次响应。所以客户端每次发送请求信息都要与服务端重新建立连接

HTTP1.1：克服了HTTP1.0的缺陷。在中间客户端可多次发送请求信息，服务器端也可会送多次响应信息。无须重新建立连接。有效的解决了性能问题和交互时间。

### HTTP请求消息

#### 简介

一个完整的请求消息是由**请求行**、**请求头**、**实体内容**三部分组成。每部分都有各自不同的作用。

#### 请求方式

GET（常见）：请求获取请求行的URI**所标识的资源**

POST(常见)   ：向指定资源**提交数据**（如提交表单和上传文件），请求服务器进行处理

HEAD：请求获取有URI**所标识资源的响应头**

PUT:将网页放置到指定URL位置**（上传或移动）**

DELETE:请求服务器**删除**URI所标识的资源

TRACE:请求服务器回送收到的请求信息（主要用于测试或诊断）

CONNECT:保留将来使用

OPTIONS:请求查询服务器的性能，或者查询与资源相关的选项和需求

#### 请求行

HTTP请求行位于请求消息的第一行，它包括三部分。**请求方式**、**资源路径**、**HTTP版本**

如

```
GET /index.html HTTP/1.1
```

#### HTTP请求头

在HTTP请求消息中，请求行之后，便是若干请求消息头。请求消息头主要用于向服务器端传递附加消息。例如，客户端可以接受的数据类型，压缩方式，语言以及发送请求的超链接所属页面的URL地址等。。。

如↓

```
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.9
Cache-Control:max-age=0
Connection:keep-alive
Host:www.baidu.com
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
```

- **Accept**

  用于指出客户端程序（浏览器。。。）能够处理的MIME(Multipurpose Internet Mail Extensions,多用途互联网邮件扩展)类型。例如，如果浏览器和服务器同时支持png类型的图片，则浏览器可以发送包含imgge/png的Accept头字段。服务器的检查到Accept头中包含image/png这种类型的MIME类型，可能在网页中的<img/>标签元素使用png类型文件。

  ```
  Accept:text/html  --表明客户端希望接收HTML文本
  Accept:image/gif  --表明客户端希望接收GIF图像格式资源
  Accept:imgge/*    --表明客户端可以接收所有image格式的子类型图像格式资源
  Accept：*/*       --表明客户端可以接收所有格式的内容
  ```


- Accept-Charset

  用于告知服务器端，客户端所使用的字符集。

  ```
  Accept-Charset:ISO-8859-1[,其他字符集]
  ```

- Accept-Encoding

  指定客户端能够进行解码的数据编码方式，这里的编码方式通常指的是某种压缩方式，注意跟编码集进行区别。

  gzip和compress，这两种格式是最常见的数据编码方式。在传输较大的实体内容之前，对其进行压缩编码，可以节省网络带宽和传输时间。服务器接收到这个请求头，它使用其中指定的一种格式压缩编码方式对原始文档内容进行压缩编码，然后在将其做为响应消息的实体内容发送给客户端，并且在Content-Encoding响应头中指出实体内容所使用的压缩编码格式。浏览器在接受到这样的实体内容之后，需要对其进行反向解压缩。

  ```
  Accept-Encoding:gzip【,compress】
  ```

- Accept-Language

  用于指定客户端期望服务器返回哪个国家语言的文档，它的值可以指定多个国家的语言。

  ```
  Accept-Language:zh-en【,en-us】
  ```

- Host

  用于指定资源所在主机名和端口号，格式与资源的完整URL中主机名和端口号部分相同

  ```
  Host:www.jr.com:8080
  ```

  在HTTP1.1中，客户端发送的每个请求消息中必须包含Host请求头字段，以便WEB服务器能够根据Host头字段中的主机名来区分客户端所访问的虚拟Web站点

- If-Match

  浏览器和代理服务器都可以缓存服务器回送的网页文档。当用户再次访问已缓存的页面时，只有网页内容已被更新，服务器才需要把该页面的内容重新回送到客户端，否则会通知浏览器访问本地缓存的页面，以减少不必要的网络传输流量。当服务器为客户端传送网页文件的内容时，可以传输一些代表实体内容特征的头字段，这些头字段被称为**实体标签**，当客户端再次向服务器请求这个网页文件时，可以使用If-Match头字段附带以前缓存的实体标签内容，这个请求被视为一个条件请求.

  ```
  IF-Match:"repository"  --repository:以前缓存的实体标签内容
  ```

  其中,"repository"是客户端上次访问Web服务器中该页面时,服务器使用ETag实体标签传送的内容

  ```
  ETag:"repository"
  ```

  服务器收到客户端的请求后,会检索If-Match头字段中的实体标签内容,并与服务器端的代表当前网页内容特征的实体标签内容进行比较,如果两者相同,则表示网页内容没有更改,Web服务器不返回网页文档,让客户端仍然使用以前缓存的网页文档.否则,服务器返回新的网页文件和新的实体标签内容头字段.

- If-Modified-Since

  If-Modified-Since请求头的作用和If-Match类似,只不过它的值为GMT格式的时间.If-Modified-Since请求头被视为一个请求条件,只有服务器中的文档的修改时间比If-Modified-Since请求头指定的时间新,服务器才会返回文档内容.否则,服务器将返回一个304状态码来表示客户端缓存的文档是最新的,而不想客户端返回文档内容,这时,浏览器仍使用以前缓存的文档.

- Range和If-Range

  Range头字段用于指定服务器只需返回文档中的部分内容以及内容范围,这对较大文档的断电续传非常有用.如果客户端在一次请求中直接收待服务器返回的部分内容就中断了,可以在第二次请求中,使用Range头字段要求服务器只返回中断位置之后的内容.

  **Range头字段的一下几种使用格式**

  ```
  Range:byte=1000-2000      --请求服务器返回文档中的第1000~2000个字节之间的内容
  Range:byte=1000-          --请求服务器返回文档中的第1000个字节之后的内容
  Range:byte=-1000          --请求服务器返回文档中的最后1000个字节的内容
  ```

  If-Range头字段只能伴随Range头字段一起使用,其设置值可以是实体标签或GMT格式的时间.如果设置值为实体标签,且该标签内容与服务器端代表当前的网页内容特征的实体标签内容相同,则服务器按Range头的要求返回网页中的部分内容,否则,服务器返回当前网页的所有内容,如果设置值为GMT格式的时间,并且自从这个时间以来,服务器上保存的该网页文件没有发生修改,则服务器按Range头的要求返回网页中的部分内容,否则,服务器返回当前网页的所有内容.

- Max-Forward

  指定当前请求可以途经的代理服务器数量,每经过一个代理服务器,此数量就减1.当Max-Forward请求头的值为0时,如果请求没有到达最终的Web服务器,那么最后的代理服务器将终止转发这个请求,由最后的代理服务器来响应客户端的请求.

- Referer

  浏览器向服务器发送的请求,可能是直接在浏览器中输入URL地址发出的,也可能是单击一个网页上的超链接而发出的,对于第一种直接在浏览器地址中输入URL地址的情况,浏览器不会发送Referer请求头,而对于第二种情况,浏览器会使用Referer头字段标识发出请求的超链接所在的页面的URL.

  ```
Referer:httt://www.jr.com/index.html
  ```

  Referer头字段非常有用,常被网站管理员用来追踪网站的访问者是如何导航进入网站的.同时,Referer头字段还可以用于网站的防盗链.

  **什么是盗链?**

  假设一个网站的首页想显示一些图片信息,而在该网站的服务器中并没有这些图片的资源,它通过在HTML文件中使用<img/>元素链接到其他网站的图片资源,将其展示给浏览者,这就是盗链.盗链的网站提高了自己网站的访问量,却加重了被链接网站服务器的负担,损害了其合法的利益.

- User-Agent

  User-Agent(用户代理,简称UA),它用于指定浏览器或者其他客户端程序使用的操作系统以及版本,浏览器渲染引擎,浏览器语言等.一边服务器针对不同类型的浏览器而返回不同的内容.例如,服务器可以通过User-Agent头字段,如果发现客户端是一台无限手持终端(手机),就返回WML文档;如果客户端是一个普通的浏览器,则返回通常的HTML文档

  ```

  ```

### HTTP响应消息

#### 简介

当服务器收到客户端请求后,会回送响应消息给客户端.一个完整的响应消息主要包括**响应状态行**,**响应消息头**,**实体内容**.每个组成部分都代表不同的含义.

#### 响应状态行

HTTP响应状态行位于响应消息的第一行,它包括三个部分,分别是**HTTP版本**,**状态码**,和**状态码的描述**

```
HTTP/1.1 200 OK
```

#### 响应状态码

状态码由三位数字组成,表示请求是否被理解或被满足.HTTP响应状态码的第一个数字定义了响应的类别,后面两位 没有具体分类,第一个数字有5种可能取值.

> 1xx:表示请求已接受,需要继续处理
>
> 2xx:表示请求已成功被服务器端接受,理解并接受.
>
> 3xx:为完成请求,客户端需进一步细化请求
>
> 4xx:客户端的请求有错误
>
> 5xx:服务器端出现错误

**常见状态码**

200:表示服务器成功处理了客户端的请求

302:表示请求的资源临时从不同的URI响应请求,但请求者应继续使用原有位置来进行以后的请求.例如,在请求重定向中,临时URI应该是响应消息中的Location头字段所指的资源

404:表示服务器找不到请求的资源.例如,访问服务器不存在的页面经常返回此状态码

500:表示服务器发生错误,无法处理客户端的请求

#### 响应消息头

在HTTP响应消息中,第一行为响应状态行,紧接着的是若干响应消息头,服务器端通过响应消息头向客户端传递附加信息,包括**服务程序名 **,  **被请求资源需要的认证方式**  , **客户端请求资源的最后修改时间**   ,   **重定向地址等消息.**

```
Accept-Ranges:bytes
Age:340917
Cache-Control:max-age=2592000
Content-Length:874
Content-Type:image/png
Date:Mon, 16 Apr 2018 10:33:06 GMT
ETag:"5acf2349-36a"
Expires:Sat, 12 May 2018 11:51:08 GMT
Last-Modified:Thu, 12 Apr 2018 09:13:45 GMT
```

- Accept-Range

  说明服务器是否接受客户端使用Range请求头字段请求资源.

  如果服务器想告诉客户端不要使用Range头字段,则使用下面的头信息

  ```
  Accept-Range:none
  ```

  如果服务器想告诉客户端可以使用以byte为单位的Range头字段,则使用下面的头信息

  ```
Accept-Range:byte
  ```

- Age

  指出当前网页文档可以在客户端或代理服务器中缓存的有效时间(单位秒)

  ```
  Age:1234567       
  ```

  客户端再次访问已缓存的某个网页文档内容时,先用当前的时间值减去服务器返回该网页时所设置的Date头字段值,如果结果小于Age字段值,客户端直接使用缓存中的网页内容.否则,客户端将向服务器重新发出请求获取最新网页文档.

- Etag

  向客户端传送代表实体内容特征的标记信息,这些标记信息称为实体标签,每个版本的资源的实体标签时不同的,通过实体标签可以判断在不同时间获得的同意资源路径下的实体内容时相同的.例如,在一个文档最后添加一个回车换行,Etag头字段的值就能表示不同.

  ```
  Etag:abc123456
  ```

- Location

  通知客户端获取请求文档的最新地址,其值为一个使用绝对路径的URL地址

  ```
  Location:http://www.baidu.com
  ```

  Location头字段和大多数3xx状态码配合使用,以便通知客户端字段重新连接到最新的地址请求文档.由于当前响应并没有直接返回内容给客户端,所以使用Location头的HTTP消息不应该有实体内容,由此可见,在HTTP消息头中不应该同时出现Location和Content-Type这两个头字段.

- Retry-After头字段可以与503状态码配合使用,告诉客户端在什么时间可以重新发送请求.也可以与任何一个3xx状态码配置使用,告诉客户端处理重定向的最小延时时间.

  Retry-After头字段的值可以是GMT格式的时间也可以时以秒为单位的时间数

  ```
  Retry-After：Mon,18 Nov 2013 19:01:51 GMT
  Retry-After:120          --120秒
  ```

- Server

  告知客户端该服务器软件产品的名称

  ```
  Server:Apache-Coyote/1.1
  ```

- Vary

  用于指定影响了服务器所生成的响应实体内容的那些请求头字段名

  ```
  Vary:Accept-Language
  ```

  上面的响应头字段说明了服务器响应的实体内容受到了客户端发送的Accept-Language请求头的影响，服务器根据Accept-Language请求头的值，返回相应语言种类的网页内容。

  当客户端再次访问已经缓存的资源时，需要检查Vary头字段中指定的请求头字段，检查请求头字段的这次设置与上次的设置是否相同，以此作为是否使用缓存的条件

  例如，上次请求中Accept-Language头字段的值为en-us，而这次的Accept-Language头字段的值为zh-cn，即使客户端使用请求资源路径的本地缓存的其他条件都成立，但客户端也不能使用缓存，需要重新发出访问请求资源.

- Refresh

  告诉浏览器字段刷新页面的时间,它的值可以是以秒为单位的时间数

  ```
  Refresh:3
  ```

  需要注意的是,在Refresh头字段的时间值后面还可以增加一个URL参数,时间值与URL之间用分号(;)分隔,告诉浏览器在指定的时间值后跳转到其他页面

  ```
  Refresh:3;url=http://www.baidu.com
  ```

- Content-Disposition

  如果服务器希望浏览器不是直接处理响应的实体内容,而是让用户选择将响应的实体内容保存到一个文件中,这需要使用Content-Disposition头字段.在Content-Disposition指定了接受程序处理数据内容的方式,有**inline**和**attachment**两者标准方式.

  inline表示直接处理

  attachment则要求用户干预并控制接受程序处理数据的方式.在attachment后面还可以指定filename参数.

  filename参数值是服务器建议浏览器保存实体内容的文件名称.

  ```
Content-Disposition:attachment;filename=jr.zip
  ```

  **注意**

  在设置Content-Disposition之前一定要设置Content-type响应字段头

####通用头字段

在HTTP消息中,有些头字段既适用与请求消息也适用于响应消息,这样的字段被称为通用头字段.

- Cache-Control

  如果Cache-Control用在请求消息中,它用于通知位于客户端和服务器端之间的代理服务器如何使用已缓存的页面.

  如果是Cache-Control用在响应消息中,它用于通知客户端和代理服务器如何缓存页面.

  **Cache-Control取值含义**

  > **public**:文档可以被任何客户端缓存

  ​

  > **private**:文档只能被保存在单个用户的私有缓存中

  ​

  > **no-cache**:如果no-cache后没有指定字段名,则客户机和代理服务器不应该缓存该文件.也可以在no-cache后指定一个或多个其他的头字段名.这样代理服务器可以缓存该页面内容对以后的请求进行响应,但响应消息中不能包含no-cache后指定的头字段.
  >
  > 例如,不想让客户端和代理服务器缓存Cookie信息,可以使用no-cache=Set-Cookie

  ​

  > **no-store**:请求和响应消息都不应被存储在对方的磁盘系统上,存储与缓存是有区别的.缓存是将信息保存在内存或磁盘系统中,而存储专将信息保存在磁盘系统.

  ​

  > **must-revalidate**:对于客户端的每次请求,代理服务器必须向服务器验证缓存的文档是否过时,以保证总是发送最新的文档给客户端.

  ​

  > **proxy-revalidate**:除了只能用于共享缓存外,其作用与must-revalidate相同,因为可能有多台代理服务器,一级一级向上请求知道最终服务器.故为了保证客户端向服务器端请求经过的每级代理服务器得到服务器的文档是最新的

  ​

  > **max-age=n:**在n秒后认为文档过时,它可以替代Expires头的作用,如果响应头同时给出Cache-Control头的max-age设置值和Expires头,则以Cache-Control头的max-age为准

  ​

  > **s-max-age=n:**在代理服务器中缓存的文档(通常称为共享缓存)在n后过时

- Connection

  指定处理完本次请求/响应后,客户端和服务器端是否还要继续保持连接.

  ```
  Connection:Keep-Alive        --继续连接
  Connection:close             --关闭连接
  ```

  对于HTTP1.1版本来说,默认采用持久连接,也就是说,默认情况下Connection头字段的值是Keep-Alive.

- Date

  表示HTTP消息产生的当前时间,它的值为GMT格式

  ```
  Date:Mon,18 Nov 2013 19:01:51 GMT
  ```

- Transger-Encoding

  对于HTTP1.1来说,由于服务器端和客户端保持持久连接,服务器端必须在响应消息中通过Content-Length头字段通知客户端响应数据的长度,客户端才能知道数据合适传输完毕.

  然而,在服务器端,有些数据是动态生成的,服务器必须等所有内容生成后才能准确地计算出响应数据的长度,也就是说只有当前所有数据生成完毕后服务端才能响应客户端的请求.

  这样势必会影响效率.为了解决这个问题,Transger-Encoding头字段被引入,这个头字段指定响应消息的实体内容采用哪种传输编码方式,目前标准设置值只有**chunked**

  ```
  Transger-Encoding:chunked
  ```

  **chunked传输编码方式**

  当响应消息中设置了Transger-Encoding头字段后,会把响应消息的整个实体内容分成一连串后在进行传输.

  每个分段的开始都是一个十六进制的数据,用来表示整个分段的大小.最后一个分段必须是0,表示整个chunked编码数据的结束.

  如下一个完整的响应消息

  ```
  HTTP/1.1 200 OK
  Content-Type:text/html
  Transfer-Encoding:chunked

  7f
  <html>
  <head>
  <title>Trailer Example</title>
  </head>

  2c
  <body>
  </body>
  </html>

  0
  ```

上面的响应消息中的,7f和2c代表两个分段内容的大小标识信息

在有了Transfer-Encoding头字段之后不必用Content-Length头字段来指定实体内容的大小

- Content-Range

  指定服务器返回实体内容的位置信息.只有客户端使用了Range请求头要求服务器返回实体的部分内容是,服务器的响应头中才会包含Content-Range头

  ```
  Content-Range:bytes 21010-47021/47022
  ```

  在Content-Range头字段中,bytes说明后面的数据以byte单位,21010~47021说明返回的内容从第21010个字节开始到47021个字节结束,/47022说明整体实体内容的大小为47022个字节.

- Content-Type

  指出实体内容的MIME类型.由于通过HTTP传输的数据也有各种类型,因此,HTTP也采用了MIME来标识不同的数据类型.客户端通过检查响应头字段的Content-Type中的MIME类型,就能知道接收到的实体内容代表哪种格式的数据类型,从而进行正确的处理.

  Content-Type头字段中的MIME类型后面还可以指定响应内容所使用的字符码表,两者之间用分号(;)和空格隔开.

  如

  ```
  Content-Type:text/html; charset=UTF-8
  ```

  如果头字段中没有指定字符码表,默认使用ISO-8859-1

- Content-Encoding

  指定实体内容的压缩编码方式.服务器对实体内容的压缩不会影响实体内容的MIME类型,当被压缩的实体内容在客户端被解压后,其MIME类型与Content-Type头字段指定的类型一致

- Expires

  指定当前文档的过期时间,浏览器在这个时间以后不能在继续使用本地缓存,而需要向服务器发出新的访问请求.

  Expires头字段的设置值应该为GMT格式时间.

  ```
  Expires:Mon,18 Nov 2013 19:01:51 GMT
  ```

  由于浏览器的兼容问题,在设置网页不缓存时,一般将Pragma,Cache-Control,Expires三个字段一起使用;

- Last-Modified

  指定文档最后的更改时间,设置值为GMT格式的时间.当客户端接收到Last-Modified头字段后,它将在以后的请求消息中发送一个If-Modified-Since请求消息头来指出缓存文档的最后更新时间,也就时Last-Modified响应头中的时间,就是下次请求消息中If-Modified-Since请求字段头指定的时间.

  ​

# Servlet

### 简介

随着Web应用业务需求的增多,动态Web资源的开发变得越来越重要.目前,很多公司都提供了开发动态Web资源的相关技术,其中比较常见的有ASP,PHP,JSP和Servlet等.基于Java的动态Web资源开发,Sun公司提供了Servlet和JSP两种技术

### 创建Servlet对象

#### 实现 Servlet接口

```
public class MyGenericServlet implements Servlet {
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}

```

- void init(ServletConfig config)

负责Servlet初始化工作.容器在创建号Servlet对象后,就会调用此方法.该方法接受一个ServletConfig类型的参数,Servlet容器通过这个参数向Servlet传递初始化配置信息

- ServletConfig getServletConfig()

返回容器调用init(ServletConfig config)方法时传递给Servlet的ServletConfig对象

- String getServletInfo()

返回一个字符串,其中包含关于Servlet的信息.例如,作者,版本,和版权信息等

- void service(ServletRequest request,ServletResponse response)

负责响应用户请求,当容器接受到客户端访问Servlet对象的请求时,就会调用此方法.容器会构造一个表示客户端请求信息的ServletRequest对象和一个响应客户端的ServletResponse对象作为参数传递给service()方法.在service()方法中,可以通过ServletRequest对象得到客户端的相关信息和请求信息,在对请求进行处理后,调用ServletResponse对象的方法设置响应信息.

- void destroy()

负责释放Servlet对象占用的资源.当Servlet对象被销毁时,容器会调用此方法.

#### 继承Servlet对象实现Servlet方法

由于直接实现Servlet接口来编写Servlet很不方便,需要实现很多方法.

- 因此可以通过继承Servlet接口的实现类javax.servlet.GenericServlet来实现

```
public class MyGenericServlet extends GenericServlet{
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

    }
}

```

MyGennericServlet继承GenericServlet后,只实现了service()方法.这是因为GenericServlet类除了Servlet接口的service()方法外,其他方法都已经实现.由此可见.继承GenericServlet比实现Servlet接口更加简便.

- 通过继承Servlet接口的实现类javax.servlet.http.HttpServlet来实现

它是GenericServlet的子类,专门用于创建应用与HTTP大的Servlet.

```
@WebServlet(name = "Servlet")
public class MyHttpServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }
}

```

**HttpServlet主要有两大功能**

1. 根据用户的请求方式的不同,定义相应的doXXX()方法处理用户请求.如,与GET请求方式对应的doGet()方法,

   与POST方式对应的doPost()方法.

2. 通过service方法将HTTP请求和响应分别转为HttpServletRequest和HttpServletResponse类型对象

需要注意的是,由于HttpServlet类在重写的service()方法中,为每一种HTTP请求方式都定义了对应的doxxx()方法,因此,当定义的类继承HttpServlet后,只需根据请求方法,重写对应的doxxx()即可,不需要重写service()方法.

### Servlet的映射

```
<servlet>
    <servlet-name>Myhttpservlet</servlet-name>
    <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>Myhttpservlet</servlet-name>
    <url-pattern>/myhttpservlet</url-pattern>
</servlet-mapping>
```

上面的配置信息中,元素<servlet>用于注册Servlet,它的两个元素<servlet-name>和<servlet-class>分别指定Servlet名称及其完整类名

元素<servlet-mapping>用于映射Servet对外访问的虚拟路径,它的子元素<servlet-name>必须和<servlet>中的<servlet-name>相同,元素<url-pattern>则是用于指定访问该Servlet的虚拟路径,该路径以"/"开头,代表当前的Web应用的根目录

#### Servlet的多重映射

Servlet的多重映射指的是同一个Servlet可以被映射成多个虚拟路径.也就是说,客户端可以通过多个路径对同一个Servlet进行访问.

- 配置多个<servlet-mapping>元素

  ```
      <servlet>
          <servlet-name>Myhttpservlet</servlet-name>
          <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
          <load-on-startup>1</load-on-startup>
      </servlet>
      <servlet-mapping>
          <servlet-name>Myhttpservlet</servlet-name>
          <url-pattern>/myhttpservlet01</url-pattern>
      </servlet-mapping>
      <servlet-mapping>
          <servlet-name>Myhttpservlet</servlet-name>
          <url-pattern>/myhttpservlet02</url-pattern>
      </servlet-mapping>
  ```

- 在<servlet-mapping>元素中配置多个<url-pattern>子元素

  ```
      <servlet>
          <servlet-name>Myhttpservlet</servlet-name>
          <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
          <load-on-startup>1</load-on-startup>
      </servlet>
      <servlet-mapping>
          <servlet-name>Myhttpservlet</servlet-name>
          <url-pattern>/myhttpservlet01</url-pattern>
          <url-pattern>/myhttpservlet02</url-pattern>
      </servlet-mapping>
  ```

#### Servlet映射路径中使用通配符

有时候,我们希望某个目录下的所有路径都访问同一个Servlet,这时,可以在Servlet映射的路径中使用通配符"*"

- 格式为"\*.扩展名",例如"\*.do"匹配以".do"结尾的所有URL地址
- 格式为"/\**" ; 例如"abc/*\*"匹配以abc开始的所有URL地址

**注意**

两种格式不能混合使用

#### 自动加载Servlet程序

有时候,我们希望某些Servlet程序可以在Tomcat启动是随机启动.例如,当启动一个Web项目时,首先需要对数据库信息进行初始化.

那么可以在Web.xml文件中映射Servlet时,添加<servlet>的一个子元素<load-on-startup>

在<load-on-startup>元素中,其值必须是一个整数.如果这个值是一个负数,或者没有设定这个元素,Servlet容器将在客户端首次请求这个Servlet时加载它;如果这个值是正整数或0,Servlet容器将在Web应用启动时加载并初始化Servlet.

值越小,它对应的Servlet就越被优先加载

```
<servlet>
    <servlet-name>Myhttpservlet</servlet-name>
    <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>Myhttpservlet</servlet-name>
    <url-pattern>/myhttpservlet</url-pattern>
</servlet-mapping>
```

#### 

### Servlet的声明周期



![Servlet的声明周期](E:\笔记\JavaWeb\photo\Servlet的声明周期.jpg)



根据功能的不同,大致可以将Servlet的生命周期分为三个阶段,分别是**初始化阶段**,**运行阶段**,和**销毁阶段**

- 初始化阶段

  当客户端向Servlet容器发出HTTP请求要求访问Servlet时,Servlet容器首先会解析请求,检查内存中是否已经有了该Servlet对象,如果有直接使用该Servlet对象,如果就创建Servlet实例对象,然后通过调用init()方法实现Servlet的初始化工作,需要注意的是,在Servlet的整个生命周期内,它的init()方法只被调用一次

- 运行阶段

  这是Servlet声明周期中最重要的阶段,在这个阶段,Servlet容器会为这个请求创建代表HTTP请求的ServletRequest对象和代表HTTP响应的ServletResponse对象,然后将它们作为参数传递给Servlet的service()方法.service()方法从ServletRequest对象中获取客户请求信息和处理该请求,通过ServletResponse对象生成响应结果.在Servlet的整个生命周期内,对于Servlet的每次访问请求,Servlet容器都会调用一次Servlet的service()方法,并且创建新的ServletRequest和ServletResponse对象,也就是说,service()方法在Servlet的整个生命周期终会被调用多次.

- 销毁阶段

  当服务器关闭或Web应用被移除容器时,Servlet随着Web应用的销毁而销毁.在销毁Servlet之前,Servlet容器会调用Servlet的destory()方法,以便让Servlet对象释放它所占的资源.在Servlet的整个生命周期中,destroy()方法也只被调用一次.



# ServletConfig

### 简介

在Servlet运行期间,经常需要一些辅助信息,例如,文件使用的编码,使用Servlet程序的公司等,这些信息可以在web.xml文件使用一个或多个<init-param>元素进行配置.当Tomcat初始化一个Servlet时,会将该Servlet的配置信息封装到一个ServletConfig对象中,通过调用init(ServletConfig config)方法将ServletConfig对象传递给Servlet.

```
   <servlet>
        <servlet-name>Myhttpservlet</servlet-name>
        <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
        <init-param>
            <param-name>初始化参数名</param-name>
            <param-value>初始化参数值</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>Myhttpservlet</servlet-name>
        <url-pattern>/myhttpservlet01</url-pattern>
    </servlet-mapping>
```

### ServletConfig常用方法

- String getInitParameter(String name)

  根据初始化参数名返回对应的初始化参数值

- Enumeration getInitParameterNames()

  返回一个Enumeration对象,包括所有的初始化参数名

- ServletContext getServletContext

  返回代表Web应用的ServletContext对象

- String getServletName()

  返回Servlet的名字,即web.xml中<servlet-name>元素的值

# ServletContext

### 简介

当Servlet容器启动时,会为每个Web应用创建一个唯一的ServletContext对象代表当前Web应用,该对象不仅封装了当前Web应用的所有信息,而且实现了多个Servlet之间的数据共享.

### 配置Web应用的初始化参数

```
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0"
         metadata-complete="true">
<context-param>
    <param-name>参数名</param-name>
    <param-value>参数值</param-value>
</context-param>
</web-app>
```

### 获取Web应用的初始化参数

- Enumeration getInitParameterNames()

  得到包含所有初始化参数名的Enumeration对象

- String getInitParameter(String name) 

  根据参数名获取参数值

### 多个Servlet对象共享数据

由于一个Web'应用中所有Servlet共享同一个ServletContext对象,因此ServletContext对象的域属性可以被该Web应用中的所有Servlet访问.在ServletContext接口中定义了分别用于增加,删除,设置ServletContext域属性的4个方法.

- Enumeration getAttributeNames()

  返回一个Enumeration对象,该对象包含所有存放在ServletContext中的所有域属性名

- Object getAttbute(String name)

  根据参数指定的属性名返回一个与之匹配的域属性值

- void removeAttribute(String name)

  根据参数指定的域属性名,从ServletContext中删除匹配的域属性

- void setAttribute(String name,Object obj)

  设置ServletContext的域属性,其中name时域属性名,obj时域属性值

#### 注意

ServetContext的数据是全局,共享的.

也就是说一个客户端对数据的修改,对另外其他客户端而言是已知的

所以一般不在ServletContext进行数据的传递

# 请求和响应

### 简介

Servlet最主要的作用就是处理客户端请求,并向客户端做出响应.为此,针对Servlet的每次请求,Web服务器在调用service()之前,都会创建两个对象,分别时HttpServletRequest和HttpServletResponse.

其中,HttpServletRequest用于封装HTTP请求消息,简称request对象.

HttpServletResponse用于封装HTTP响应消息,简称response对象.

![客户端访问Servlet流程图](E:\笔记\JavaWeb\photo\客户端访问Servlet流程图.jpg)



### HttpServletResponse对象

在Servlet API中,定义了一个HttpServletResponse对象,它继承自ServletResponse,专门用来封装HTTP响应消息.由于HTTP响应消息分为**状态行**,**响应消息头**,**消息体**三部分,因此,在HttpServletResponse接口中定义了向客户端发送响应状态码和响应消息头,响应消息体的方法.

#### 发送状态码的相关方法

- setStatus(int status)

  该方法用于设置HTTP响应消息的状态码,并生成响应状态行.由于响应状态行中的状态描述信息直接与状态码相关,而HTTP版本有服务器确定,因此,只要通过setStatus(int status)方法设置了状态码,即可实现状态行的发送.

  正常情况下,Web服务器会默认产生一个200的状态行.

- setError(int sc)

  发送表示错误信息的状态行,例如,404状态码表示找不到客户端请求的资源.

- setError(int sc,String message)

  附加一条用于提示说明的文本信息,该文本信息将出现在发送给客户端的正文内容中

#### 发送响应消息头的相关方法

- void addHeader(String name,String value)

  void setHeader(String name,String value)

  这两个方法都是用来设置HTTP的响应头字段,其中,参数name用于指定响应头字段的名称,参数value用于指定响应头字段的值.不同的是,addHeader()方法可以增加同名的响应头字段,而setHeader()会覆盖同名的前头字段

- void addIntHeader(String name,int value)

  void setIntHeader(String name,int value)

  这两个方法专门用于设置包含整数的响应头.避免了使用addHeader()和serHeader()方法时,需要将int类型的设置值转换为String类型的麻烦

- void setContentLength(int length)

  该方法用于设置相应消息的实体内容的大小,单位为字节.对于HTTP来说,这个方法就是设置了Content-Length响应头字段的值

- void setContentType(String type)

  该方法用于设置Servlet输出内容的MIME类型,对于HTTP来说,就是设置了Content-Type响应头字段的值.

- void setLocale(Locale loc)

  该方法用于设置响应消息的本地化信息.对于HTTP消息来说,就是设置Content-Language响应头字段和Content-Type头字段的字符集编码部分.

- void setCharacterEncoding(String charset)

  该方法用于设置输出内容使用的字符编码,对HTTP来说,就是设置Content-Type头字段中的字符集编码部分.

  如果没有设置Content-Type头字段,setCharacterEncoding方法设置的字符集编码不会出现在HTTP消息的响应头中.

  setCharcterEncoding()方法比setContentType()和setLocale()方法的优先级高.它设置的字符集结果会覆盖setContentType()和setLocale()方法所设置的字符集表

#### 发送响应消息体的相关方法

- getOutputStream()

  该方法所获取的字节输出流对象为ServletOutputStream类型.由于ServletOutputStream时OutputStream的子类,它可以直接输出字节数组的二进制数据.

- getWriter()

  该方法所获取的字符输出流对象为PrintWriter类型.PrintWriter类型的对象可以直接输出字符文本内容

##### 注意

虽然respone对象的getOutputStream()和getWriter()方法都可以发送响应消息体,但是,它们之间相互排斥,不可以同时使用,否则会发送IllegeStateException异常

因为getWriter()方法内部调用了getOutputStream().

#### HttpServletResponse应用

##### 中文输出乱码问题

由于计算机中的数据都是以二进制形式存储的,因此,当传输文本时,就会发生字符和字节之间的转换.字符与字节之间的转换时通过查码表完成的,将字符转换成字节的过程称之为**编码**,将字节转换成字符的过程称之为**解码**,如果编码和解码使用的码表不一致就会导致乱码问题.

由于response对象的字符输出流在编码时,默认采用的是ISO 8859-1的字符码表,该码表不兼容中文.

而浏览器默认采用GB2312码表进行解码,所以必定会造成乱码.

**解决方法**

- 分两部走

1. 指定response存储引擎编码码表

```
response.setChatacterEncoding("utf-8");
```

2. 通知浏览器使用码表解码

```
response.setHeader("Content-Type","text/html;charset=utf-8");
```

- 一步解决

```
response.setContentType("text/html;charset=utf-8");
```

##### 页面定时刷新并跳转

在HTTP中,定义了一个Refresh头字段,它可以通知浏览器在指定时间内自动刷新并跳转到其他页面.

```
response.setHeader("Refresh","2")                    --两秒后进行刷新
response.setHeader("Refresh","2;URL=跳转地址")        --两秒后进行跳转到指定地址
```

##### 禁止浏览器缓存页面

```
response.setDateHeader("Expires",0);
response.setHeader("Cache-Control","no-cache");
response.setHeader("Pragma","no-cache");
```

由于不同浏览器对他们的支持不同,一般在响应消息中将这个三个头字段都设置

##### 请求重定向

为了实现请求重定向,在HttpServletResponse接口中,定义了一个sendRedirect()方法

该方法用于生成302响应码和Location响应头字段,从而通知客户端重新访问Location响应头中指定的URL.

```
response.sendRedirect("http://www.jr.com");

```

### HttpServletRequest对象

 #### 获取请求行信息的相关方法

- String getMethod（）

  获取HTTP请求信息中的请求方式（GET.POST...）

- String getRequestURI（）

  获取请求行中的资源名称部分，即位于URI的主机名和端口号之后，参数部分之前的部分

- String getQueryString（）

  获取请求行中的参数部分，即“?”之后的所有内容

- String getProtocol（）

  获取请求行中的协议名和版本，例如，HTTP1.0或HTTP1.1

- String getContextPath（）

  获取请求URL中属于Web应用程序的路径，这个路径以“/“开头，表示相对域整个Weeb站点的根目录，路径结尾不含”/“。

- String getPathInfo（）

  获取请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以”/“开头。如果没有额外路劲信息部分，返回null

- String getPathTranslated（）

  获取URL中额外路径信息所对应的资源的真实路径。

#### 获取请求消息头的相关方法

- String getHeader（String name）

  获取一个指定头字段的值，如果请求消息中不存在指定的头字段，返回null。如果消息头中包含多个指定的头字段。返回第一个头字段的值。

- Enumeration getHeaders（String name）

  该方法返回一个Enumeration集合对象，该集合对象由请求消息头中出现的某个指定名称的所有头字段值组成

- Enumeration getHeaderNames()

  获取一个包含所有请求头字段的Enumeration对象

- int getIniHeader（String name）

  获取指定名称的头字段值，并将其值转换成int类型。

- long getDateHeader（String name）

  获取指定名称的头字段值，并将其值按GMT时间格式转换成一个代表日期/时间的长整数

- String getContentType（）
  获取Content-Type头字段的值

- int getContentLenth（）

  获取Content-Lenght头字段的值

- String getCharacterEncoding（）

  获取请求消息的实体部分的字符集编码，通常是从Content-Type头字段中提取。

####获取请求消息体的相关方法

- ServletInputStream getInputStream（）

  获取表示实体内容的ServletInputStream对象，如果实体内容为非文本，那么只能通过getInputStream（）方法获取请求消息体

- BufferedReader getReader（）

  获取实体内容的BufferedReader对象，该对象会将实体内容中的字节数据按照请求消息中指定的字符集编码转换成文本字符串。

  也可使用setCharacterEncoding（）方法指定BUfferedReader对象所使用的字符编码。

  如果请求消息没有指定字符集编码，而BufferedReader又没指定字符集编码，那么将默认采用ISO-8859-1

#### HttpServletRequest应用

##### 获取请求参数

- String getParameter（String name）

  获取指定名称的参数值

  如果请求消息中没有存在指定名称的参数，返回null

  如果存在指定名称的参数，但没有设置值，返回”“

  如果存在多个指定名称的参数，返回第一个参数值

- String 【】 getParameterValues（String name）

  获取同一参数名对应的所有参数值

- Enumeration getParameterNames（）

  返回请求消息中的所有参数名的Enumeration对象

- Map getParameterMap（）

  将请求消息中的参数名和参数值封装到一个Map集合

##### 请求参数中文乱码问题

浏览器在传递请求参数时，默认采用的编码方式时GBK，但在解码时采用的是默认的ISO-8869-1，因此出现了参数信息乱码问题

**解决方法**

```
request.setCharacterEncoding("utf-8");  --设置request对象的解码方式
```

**但仅对POST方式有效**

因为setCharacterEncoding（）方法仅对实体内容数据设置有效

而GET方式请求中的参数是附加到请求行内，因此方法对GET方式无效

**GET解决方法**

- 使用错误码表再次编码后在使用正确码表解码

  ```
  name=new String(name.getBytes("错误码表"),"正确码表")
  ```

##### 获取网络连接信息

- String getRemoteAddr（）

  获取请求客户端的IP地址

- String getRemoteHost（）

  获取请求客户端的完整主机名

- int getRemotePort（）

  获取请求客户端网络连接的端口号

- 。。。

##### 通过Request对象传递数据

- setAttribute(String name,Object obj)

  将一个对象与一个名称关联后存储进ServletRequest对象

  如果已存在就覆盖原有值

- getAttribute（String name）

  从ServletRequest对象中获取指定名称的属性对象

- removeAttribute（String name）

  从ServletRequest对象中删除指定名称的属性对象

- getAttributeNames（）

  返回一个包含ServletRequest对象中所有属性名的Enumeration对象

######注意

只属于同一次请求中的数据才可以通过ServletRequest对象传递数据

##### RequestDispatcher对象的应用

当一个Web资源收到客户端的请求后，如果希望服务器通知及另外一个资源去处理请求，除了使用sendRedirect（）方法让**客户端去实现请求重定向外**，还可以通过RequestDispatcher接口的实例对象来让**服务器端实现请求转发**

###### 步骤

1. 获取RequestDispatcher对象

- RequestDispatcher getRequestDispatcher（String path）

  返回封装了某个路径所指资源的RequestDispatcher对象。

  其中，参数path必须以"/"开头，用于表示当前Web应用的根目录

2. 通知其他Web资源处理当前Servlet请求

- forward（ServletRequest request，ServletResponse response）

  将请求从一个Servlet传递给另外一个Web资源。最后由它发送响应消息

- include（ServletRequest request，ServletResponse response）

  将其他的资源作为当前响应内容包含进来

  ​

# 会话及其会话技术

### 简介

当用户通过浏览器访问Web应用时，通常情况下，服务器需要对用户的状态进行跟踪。

例如，用户在网站结算商品时，Web服务器必须根据请求用户的身份，找到该用户所购买的商品。

在Web开发中，服务器跟着用户信息的技术称为会话技术。





