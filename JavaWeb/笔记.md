# 互联网常见协议

​       **协议**         **工作端口**

- http           80         
- smtp         25
- pop3         110
- ftp              23
- https          443

# Tomcat启动失败原因

- JAVA_HOME环境未配置

由于Tomcat依赖于java环境，所以Tomcat找不到JDK环境，就启动不了Tomcat

- 端口被占用
- Catalina_home环境变量的设置问题

Catalina_home环境变量：配置Tomcat位置

startup.bat（启动Tomcat），首先会在环境变量中启动Catalina_home配置中的Tomcat。所以，如果你配置了Catalina_home的话，在本地盘中有多个Tomcat服务器，假若你运行的是C盘中的startup.bat，但你Catalina_home配的是D盘的Tomcat，则它启动的D盘的Tomcat。



# Tomcat目录结构

- bin                            存放启动和关闭Tomcat等的脚本文件
- conf                          存放Tomcat的各种配置文件(如配置Tomcat运行端口的server.xml文件)
- lib                              存放Tomcat支持的jar包
- logs                           存放Tomcat的日志文件（如Tomcat黑窗口中的输出信息）
- temp                         存放Tomcat运行是产生的临时文件。对于WEB开发者来说不必关心，只供Tomcat服务器开发者有用
- webapps                  存放Web开发的应用，即供外界访问的Web资源存放目录
- work                         Tomcat的工作目录，如Tomcat在运行中将JSP转换成Servlet代码，这些Servlet代码就存放在工作目录中



# WEB应用的组成结构

- mail					WEB应用所在目录
- html,jsp,css,js文件等            这些文件一般存在WEB应用根目录下，根目录下的文件外界可以直接访问
- WEB-INF                                java类，jar包，web应用的配置文件存在这个目录下，该目录下的文件外界无法直接访问，有web服务器负责调用
- WEB-INF/classes                  java类
- WEB-INF/lib                          jar包
- WEB-INF/web.xml               WEB应用配置文件

# 虚拟目录的映射

**WEB应用:**  WEB应用程序指供浏览器访问的程序，通常称为WEB应用

**WEB目录：**存放WEB应用程序的目录，称之为WEB目录

**虚拟目录的映射:** WEB应用开发好后，若想供外界访问，需要将WEB目录交给WEB服务器管理，这个过程称之为虚拟目录的映射。



### 虚拟目录映射方式

- 在conf\server.xml目录下配置<Context/>

```
<Context path="/外界访问的虚拟目录"  docBase="WEB目录"/>
```

**特点**：加入WEB服务器（Tomcat）在C盘，而开发的工作环境目录在D盘，那么就可以通过这种方式，直接将D盘的WEB应用目录映射到Tomcat中。**但需要重启Tomcat。**

- 在conf\Catalina\localhost下创建**文件名.XML**，在XML文件下配置<Context/>

1. 文件名：外界访问的虚拟目录
2. 文件下配置

**技巧：**如果需要进行多级的虚拟目录（即：localhost:8080**/a/b/c**）,那么可通过取文件名的时候在每级目录名用”#“进行分割

如：创建一个多级目录localhost:8080**/a/b/c**，则文件名就是：a#b#c.xml

**特点**：加入WEB服务器（Tomcat）在C盘，而开发的工作环境目录在D盘，那么就可以通过这种方式，直接将D盘的WEB应用目录映射到Tomcat中。**无需重启Tomcat。**

```
<Context docBase="WEB目录"/>
```

- 直接将WEB应用放在webapps下，Tomcat会自动映射

**特点**：**方便快捷。无需重启Tomcat。**但会只能跟随Tomcat服务器目录，所以如果Tomcat放在C盘，则会消耗C盘空间。



# 配置虚拟主机

### 简介

在一个tomcat服务器中可以放置多个网站，所谓配置虚拟主机，就是在tomcat服务器中放置一个网站

### 方法

使用服务器配置文件（server.xml）中用户Host元素标签进行配置。

```
<Host name="主机名" appBase="站点目录"/>
```

配置完虚拟主机之后在配置该站点的WEB应用。

```
<Host name="主机名" appBase="站点目录">
<Context path="虚拟目录" docBase="WEB应用实际目录" />
<Host/>
```



# 浏览器访问Web资源的流程

![浏览器访问Web资源的流程图](E:\笔记\JavaWeb\photo\浏览器访问Web资源的流程图.png)

### 主机名作用

1. 通过主机名搜索DNS服务器查找服务器IP
2. 在发送HTTP请求中携带主机名，确定访问的站点



# WEB应用打包

### 命令

```
jar -cvf 包名.war WEB应用目录
```

###jar命令参数

![jar参数](E:\笔记\JavaWeb\photo\jar参数.bmp)

### 打包

![WEB应用打包](E:\笔记\JavaWeb\photo\WEB应用打包.bmp)

将war包直接放在tomcat的默认虚拟主机目录（webapps）下，tomcat会自动识别解压.

# Tomcat体系架构

1. Tomcat启动时会启动一个Service（服务）

2. 这个服务会启动多个Connector(连接器),不同连接器处理不同请求。如处理HTTP，HTTPS（加密请求）。。。

3. 连接器处理请求时会找Tomcat引擎（Engine）

4. Engine会找请求的虚拟主机目录

5. 虚拟主机就找请求的WEB应用

6. WEB应用找到请求对应的WEB资源

   ![img](file:///E:/%E7%AC%94%E8%AE%B0/JavaWeb/photo/Tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.bmp?lastModify=1524404941)

# 配置加密连接器

- 创建数字证书

​       **Java命令**

```
keytool -genkey -alias tomcat -keyalg RSA
```

![创建数字证书](E:\笔记\JavaWeb\photo\创建数字证书.bmp)

- 在server.xml配置加密连接器

```
    <Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
clientAuth="false" sslProtocol="TLS" 
keystoreFile="conf/.keystore"     //数字证书目录
keystorePass="数字证书密钥库密码"  
    />

```

- 通过HTTPS连接器访问WEB应用

![用加密连接器访问WEB应用](E:\笔记\JavaWeb\photo\用加密连接器访问WEB应用.bmp)



# HTTP协议

### 简介

HTTP(Hyper Text Transfer Protocol)超文本传输协议。它是一种请求响应式协议，客户端在与服务端建立连接后，就可以想服务器端发送请求，这种请求被称为**HTTP请求**，服务器端接收到请求后会做出响应，称为**HTTP响应**。

### HTTP1.0和HTTP1.1的区别

一个完整的HTTP请求有四个步骤。1.建立连接→2.发送请求信息→3.响应请求信息→4.关闭连接

HTTP1.0：客户端与服务器建立连接之后，中间只能处理一次请求和发送一次响应。所以客户端每次发送请求信息都要与服务端重新建立连接

HTTP1.1：克服了HTTP1.0的缺陷。在中间客户端可多次发送请求信息，服务器端也可会送多次响应信息。无须重新建立连接。有效的解决了性能问题和交互时间。

### HTTP请求消息

#### 简介

一个完整的请求消息是由**请求行**、**请求头**、**实体内容**三部分组成。每部分都有各自不同的作用。

#### 请求方式

GET（常见）：请求获取请求行的URI**所标识的资源**

POST(常见)   ：向指定资源**提交数据**（如提交表单和上传文件），请求服务器进行处理

HEAD：请求获取有URI**所标识资源的响应头**

PUT:将网页放置到指定URL位置**（上传或移动）**

DELETE:请求服务器**删除**URI所标识的资源

TRACE:请求服务器回送收到的请求信息（主要用于测试或诊断）

CONNECT:保留将来使用

OPTIONS:请求查询服务器的性能，或者查询与资源相关的选项和需求

#### 请求行

HTTP请求行位于请求消息的第一行，它包括三部分。**请求方式**、**资源路径**、**HTTP版本**

如

```
GET /index.html HTTP/1.1
```

#### HTTP请求头

在HTTP请求消息中，请求行之后，便是若干请求消息头。请求消息头主要用于向服务器端传递附加消息。例如，客户端可以接受的数据类型，压缩方式，语言以及发送请求的超链接所属页面的URL地址等。。。

如↓

```
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.9
Cache-Control:max-age=0
Connection:keep-alive
Host:www.baidu.com
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
```

- **Accept**

  用于指出客户端程序（浏览器。。。）能够处理的MIME(Multipurpose Internet Mail Extensions,多用途互联网邮件扩展)类型。例如，如果浏览器和服务器同时支持png类型的图片，则浏览器可以发送包含imgge/png的Accept头字段。服务器的检查到Accept头中包含image/png这种类型的MIME类型，可能在网页中的<img/>标签元素使用png类型文件。

  ```
  Accept:text/html  --表明客户端希望接收HTML文本
  Accept:image/gif  --表明客户端希望接收GIF图像格式资源
  Accept:imgge/*    --表明客户端可以接收所有image格式的子类型图像格式资源
  Accept：*/*       --表明客户端可以接收所有格式的内容
  ```


- Accept-Charset

  用于告知服务器端，客户端所使用的字符集。

  ```
  Accept-Charset:ISO-8859-1[,其他字符集]
  ```

- Accept-Encoding

  指定客户端能够进行解码的数据编码方式，这里的编码方式通常指的是某种压缩方式，注意跟编码集进行区别。

  gzip和compress，这两种格式是最常见的数据编码方式。在传输较大的实体内容之前，对其进行压缩编码，可以节省网络带宽和传输时间。服务器接收到这个请求头，它使用其中指定的一种格式压缩编码方式对原始文档内容进行压缩编码，然后在将其做为响应消息的实体内容发送给客户端，并且在Content-Encoding响应头中指出实体内容所使用的压缩编码格式。浏览器在接受到这样的实体内容之后，需要对其进行反向解压缩。

  ```
  Accept-Encoding:gzip【,compress】
  ```

- Accept-Language

  用于指定客户端期望服务器返回哪个国家语言的文档，它的值可以指定多个国家的语言。

  ```
  Accept-Language:zh-en【,en-us】
  ```

- Host

  用于指定资源所在主机名和端口号，格式与资源的完整URL中主机名和端口号部分相同

  ```
  Host:www.jr.com:8080
  ```

  在HTTP1.1中，客户端发送的每个请求消息中必须包含Host请求头字段，以便WEB服务器能够根据Host头字段中的主机名来区分客户端所访问的虚拟Web站点

- If-Match

  浏览器和代理服务器都可以缓存服务器回送的网页文档。当用户再次访问已缓存的页面时，只有网页内容已被更新，服务器才需要把该页面的内容重新回送到客户端，否则会通知浏览器访问本地缓存的页面，以减少不必要的网络传输流量。当服务器为客户端传送网页文件的内容时，可以传输一些代表实体内容特征的头字段，这些头字段被称为**实体标签**，当客户端再次向服务器请求这个网页文件时，可以使用If-Match头字段附带以前缓存的实体标签内容，这个请求被视为一个条件请求.

  ```
  IF-Match:"repository"  --repository:以前缓存的实体标签内容
  ```

  其中,"repository"是客户端上次访问Web服务器中该页面时,服务器使用ETag实体标签传送的内容

  ```
  ETag:"repository"
  ```

  服务器收到客户端的请求后,会检索If-Match头字段中的实体标签内容,并与服务器端的代表当前网页内容特征的实体标签内容进行比较,如果两者相同,则表示网页内容没有更改,Web服务器不返回网页文档,让客户端仍然使用以前缓存的网页文档.否则,服务器返回新的网页文件和新的实体标签内容头字段.

- If-Modified-Since

  If-Modified-Since请求头的作用和If-Match类似,只不过它的值为GMT格式的时间.If-Modified-Since请求头被视为一个请求条件,只有服务器中的文档的修改时间比If-Modified-Since请求头指定的时间新,服务器才会返回文档内容.否则,服务器将返回一个304状态码来表示客户端缓存的文档是最新的,而不想客户端返回文档内容,这时,浏览器仍使用以前缓存的文档.

- Range和If-Range

  Range头字段用于指定服务器只需返回文档中的部分内容以及内容范围,这对较大文档的断电续传非常有用.如果客户端在一次请求中直接收待服务器返回的部分内容就中断了,可以在第二次请求中,使用Range头字段要求服务器只返回中断位置之后的内容.

  **Range头字段的一下几种使用格式**

  ```
  Range:byte=1000-2000      --请求服务器返回文档中的第1000~2000个字节之间的内容
  Range:byte=1000-          --请求服务器返回文档中的第1000个字节之后的内容
  Range:byte=-1000          --请求服务器返回文档中的最后1000个字节的内容
  ```

  If-Range头字段只能伴随Range头字段一起使用,其设置值可以是实体标签或GMT格式的时间.如果设置值为实体标签,且该标签内容与服务器端代表当前的网页内容特征的实体标签内容相同,则服务器按Range头的要求返回网页中的部分内容,否则,服务器返回当前网页的所有内容,如果设置值为GMT格式的时间,并且自从这个时间以来,服务器上保存的该网页文件没有发生修改,则服务器按Range头的要求返回网页中的部分内容,否则,服务器返回当前网页的所有内容.

- Max-Forward

  指定当前请求可以途经的代理服务器数量,每经过一个代理服务器,此数量就减1.当Max-Forward请求头的值为0时,如果请求没有到达最终的Web服务器,那么最后的代理服务器将终止转发这个请求,由最后的代理服务器来响应客户端的请求.

- Referer

  浏览器向服务器发送的请求,可能是直接在浏览器中输入URL地址发出的,也可能是单击一个网页上的超链接而发出的,对于第一种直接在浏览器地址中输入URL地址的情况,浏览器不会发送Referer请求头,而对于第二种情况,浏览器会使用Referer头字段标识发出请求的超链接所在的页面的URL.

  ```
Referer:httt://www.jr.com/index.html
  ```

  Referer头字段非常有用,常被网站管理员用来追踪网站的访问者是如何导航进入网站的.同时,Referer头字段还可以用于网站的防盗链.

  **什么是盗链?**

  假设一个网站的首页想显示一些图片信息,而在该网站的服务器中并没有这些图片的资源,它通过在HTML文件中使用<img/>元素链接到其他网站的图片资源,将其展示给浏览者,这就是盗链.盗链的网站提高了自己网站的访问量,却加重了被链接网站服务器的负担,损害了其合法的利益.

- User-Agent

  User-Agent(用户代理,简称UA),它用于指定浏览器或者其他客户端程序使用的操作系统以及版本,浏览器渲染引擎,浏览器语言等.一边服务器针对不同类型的浏览器而返回不同的内容.例如,服务器可以通过User-Agent头字段,如果发现客户端是一台无限手持终端(手机),就返回WML文档;如果客户端是一个普通的浏览器,则返回通常的HTML文档

  ```

  ```

### HTTP响应消息

#### 简介

当服务器收到客户端请求后,会回送响应消息给客户端.一个完整的响应消息主要包括**响应状态行**,**响应消息头**,**实体内容**.每个组成部分都代表不同的含义.

#### 响应状态行

HTTP响应状态行位于响应消息的第一行,它包括三个部分,分别是**HTTP版本**,**状态码**,和**状态码的描述**

```
HTTP/1.1 200 OK
```

#### 响应状态码

状态码由三位数字组成,表示请求是否被理解或被满足.HTTP响应状态码的第一个数字定义了响应的类别,后面两位 没有具体分类,第一个数字有5种可能取值.

> 1xx:表示请求已接受,需要继续处理
>
> 2xx:表示请求已成功被服务器端接受,理解并接受.
>
> 3xx:为完成请求,客户端需进一步细化请求
>
> 4xx:客户端的请求有错误
>
> 5xx:服务器端出现错误

**常见状态码**

200:表示服务器成功处理了客户端的请求

302:表示请求的资源临时从不同的URI响应请求,但请求者应继续使用原有位置来进行以后的请求.例如,在请求重定向中,临时URI应该是响应消息中的Location头字段所指的资源

404:表示服务器找不到请求的资源.例如,访问服务器不存在的页面经常返回此状态码

500:表示服务器发生错误,无法处理客户端的请求

#### 响应消息头

在HTTP响应消息中,第一行为响应状态行,紧接着的是若干响应消息头,服务器端通过响应消息头向客户端传递附加信息,包括**服务程序名 **,  **被请求资源需要的认证方式**  , **客户端请求资源的最后修改时间**   ,   **重定向地址等消息.**

```
Accept-Ranges:bytes
Age:340917
Cache-Control:max-age=2592000
Content-Length:874
Content-Type:image/png
Date:Mon, 16 Apr 2018 10:33:06 GMT
ETag:"5acf2349-36a"
Expires:Sat, 12 May 2018 11:51:08 GMT
Last-Modified:Thu, 12 Apr 2018 09:13:45 GMT
```

- Accept-Range

  说明服务器是否接受客户端使用Range请求头字段请求资源.

  如果服务器想告诉客户端不要使用Range头字段,则使用下面的头信息

  ```
  Accept-Range:none
  ```

  如果服务器想告诉客户端可以使用以byte为单位的Range头字段,则使用下面的头信息

  ```
Accept-Range:byte
  ```

- Age

  指出当前网页文档可以在客户端或代理服务器中缓存的有效时间(单位秒)

  ```
  Age:1234567       
  ```

  客户端再次访问已缓存的某个网页文档内容时,先用当前的时间值减去服务器返回该网页时所设置的Date头字段值,如果结果小于Age字段值,客户端直接使用缓存中的网页内容.否则,客户端将向服务器重新发出请求获取最新网页文档.

- Etag

  向客户端传送代表实体内容特征的标记信息,这些标记信息称为实体标签,每个版本的资源的实体标签时不同的,通过实体标签可以判断在不同时间获得的同意资源路径下的实体内容时相同的.例如,在一个文档最后添加一个回车换行,Etag头字段的值就能表示不同.

  ```
  Etag:abc123456
  ```

- Location

  通知客户端获取请求文档的最新地址,其值为一个使用绝对路径的URL地址

  ```
  Location:http://www.baidu.com
  ```

  Location头字段和大多数3xx状态码配合使用,以便通知客户端字段重新连接到最新的地址请求文档.由于当前响应并没有直接返回内容给客户端,所以使用Location头的HTTP消息不应该有实体内容,由此可见,在HTTP消息头中不应该同时出现Location和Content-Type这两个头字段.

- Retry-After头字段可以与503状态码配合使用,告诉客户端在什么时间可以重新发送请求.也可以与任何一个3xx状态码配置使用,告诉客户端处理重定向的最小延时时间.

  Retry-After头字段的值可以是GMT格式的时间也可以时以秒为单位的时间数

  ```
  Retry-After：Mon,18 Nov 2013 19:01:51 GMT
  Retry-After:120          --120秒
  ```

- Server

  告知客户端该服务器软件产品的名称

  ```
  Server:Apache-Coyote/1.1
  ```

- Vary

  用于指定影响了服务器所生成的响应实体内容的那些请求头字段名

  ```
  Vary:Accept-Language
  ```

  上面的响应头字段说明了服务器响应的实体内容受到了客户端发送的Accept-Language请求头的影响，服务器根据Accept-Language请求头的值，返回相应语言种类的网页内容。

  当客户端再次访问已经缓存的资源时，需要检查Vary头字段中指定的请求头字段，检查请求头字段的这次设置与上次的设置是否相同，以此作为是否使用缓存的条件

  例如，上次请求中Accept-Language头字段的值为en-us，而这次的Accept-Language头字段的值为zh-cn，即使客户端使用请求资源路径的本地缓存的其他条件都成立，但客户端也不能使用缓存，需要重新发出访问请求资源.

- Refresh

  告诉浏览器字段刷新页面的时间,它的值可以是以秒为单位的时间数

  ```
  Refresh:3
  ```

  需要注意的是,在Refresh头字段的时间值后面还可以增加一个URL参数,时间值与URL之间用分号(;)分隔,告诉浏览器在指定的时间值后跳转到其他页面

  ```
  Refresh:3;url=http://www.baidu.com
  ```

- Content-Disposition

  如果服务器希望浏览器不是直接处理响应的实体内容,而是让用户选择将响应的实体内容保存到一个文件中,这需要使用Content-Disposition头字段.在Content-Disposition指定了接受程序处理数据内容的方式,有**inline**和**attachment**两者标准方式.

  inline表示直接处理

  attachment则要求用户干预并控制接受程序处理数据的方式.在attachment后面还可以指定filename参数.

  filename参数值是服务器建议浏览器保存实体内容的文件名称.

  ```
Content-Disposition:attachment;filename=jr.zip
  ```

  **注意**

  在设置Content-Disposition之前一定要设置Content-type响应字段头

####通用头字段

在HTTP消息中,有些头字段既适用与请求消息也适用于响应消息,这样的字段被称为通用头字段.

- Cache-Control

  如果Cache-Control用在请求消息中,它用于通知位于客户端和服务器端之间的代理服务器如何使用已缓存的页面.

  如果是Cache-Control用在响应消息中,它用于通知客户端和代理服务器如何缓存页面.

  **Cache-Control取值含义**

  > **public**:文档可以被任何客户端缓存

  ​

  > **private**:文档只能被保存在单个用户的私有缓存中

  ​

  > **no-cache**:如果no-cache后没有指定字段名,则客户机和代理服务器不应该缓存该文件.也可以在no-cache后指定一个或多个其他的头字段名.这样代理服务器可以缓存该页面内容对以后的请求进行响应,但响应消息中不能包含no-cache后指定的头字段.
  >
  > 例如,不想让客户端和代理服务器缓存Cookie信息,可以使用no-cache=Set-Cookie

  ​

  > **no-store**:请求和响应消息都不应被存储在对方的磁盘系统上,存储与缓存是有区别的.缓存是将信息保存在内存或磁盘系统中,而存储专将信息保存在磁盘系统.

  ​

  > **must-revalidate**:对于客户端的每次请求,代理服务器必须向服务器验证缓存的文档是否过时,以保证总是发送最新的文档给客户端.

  ​

  > **proxy-revalidate**:除了只能用于共享缓存外,其作用与must-revalidate相同,因为可能有多台代理服务器,一级一级向上请求知道最终服务器.故为了保证客户端向服务器端请求经过的每级代理服务器得到服务器的文档是最新的

  ​

  > **max-age=n:**在n秒后认为文档过时,它可以替代Expires头的作用,如果响应头同时给出Cache-Control头的max-age设置值和Expires头,则以Cache-Control头的max-age为准

  ​

  > **s-max-age=n:**在代理服务器中缓存的文档(通常称为共享缓存)在n后过时

- Connection

  指定处理完本次请求/响应后,客户端和服务器端是否还要继续保持连接.

  ```
  Connection:Keep-Alive        --继续连接
  Connection:close             --关闭连接
  ```

  对于HTTP1.1版本来说,默认采用持久连接,也就是说,默认情况下Connection头字段的值是Keep-Alive.

- Date

  表示HTTP消息产生的当前时间,它的值为GMT格式

  ```
  Date:Mon,18 Nov 2013 19:01:51 GMT
  ```

- Transger-Encoding

  对于HTTP1.1来说,由于服务器端和客户端保持持久连接,服务器端必须在响应消息中通过Content-Length头字段通知客户端响应数据的长度,客户端才能知道数据合适传输完毕.

  然而,在服务器端,有些数据是动态生成的,服务器必须等所有内容生成后才能准确地计算出响应数据的长度,也就是说只有当前所有数据生成完毕后服务端才能响应客户端的请求.

  这样势必会影响效率.为了解决这个问题,Transger-Encoding头字段被引入,这个头字段指定响应消息的实体内容采用哪种传输编码方式,目前标准设置值只有**chunked**

  ```
  Transger-Encoding:chunked
  ```

  **chunked传输编码方式**

  当响应消息中设置了Transger-Encoding头字段后,会把响应消息的整个实体内容分成一连串后在进行传输.

  每个分段的开始都是一个十六进制的数据,用来表示整个分段的大小.最后一个分段必须是0,表示整个chunked编码数据的结束.

  如下一个完整的响应消息

  ```
  HTTP/1.1 200 OK
  Content-Type:text/html
  Transfer-Encoding:chunked

  7f
  <html>
  <head>
  <title>Trailer Example</title>
  </head>

  2c
  <body>
  </body>
  </html>

  0
  ```

上面的响应消息中的,7f和2c代表两个分段内容的大小标识信息

在有了Transfer-Encoding头字段之后不必用Content-Length头字段来指定实体内容的大小

- Content-Range

  指定服务器返回实体内容的位置信息.只有客户端使用了Range请求头要求服务器返回实体的部分内容是,服务器的响应头中才会包含Content-Range头

  ```
  Content-Range:bytes 21010-47021/47022
  ```

  在Content-Range头字段中,bytes说明后面的数据以byte单位,21010~47021说明返回的内容从第21010个字节开始到47021个字节结束,/47022说明整体实体内容的大小为47022个字节.

- Content-Type

  指出实体内容的MIME类型.由于通过HTTP传输的数据也有各种类型,因此,HTTP也采用了MIME来标识不同的数据类型.客户端通过检查响应头字段的Content-Type中的MIME类型,就能知道接收到的实体内容代表哪种格式的数据类型,从而进行正确的处理.

  Content-Type头字段中的MIME类型后面还可以指定响应内容所使用的字符码表,两者之间用分号(;)和空格隔开.

  如

  ```
  Content-Type:text/html; charset=UTF-8
  ```

  如果头字段中没有指定字符码表,默认使用ISO-8859-1

- Content-Encoding

  指定实体内容的压缩编码方式.服务器对实体内容的压缩不会影响实体内容的MIME类型,当被压缩的实体内容在客户端被解压后,其MIME类型与Content-Type头字段指定的类型一致

- Expires

  指定当前文档的过期时间,浏览器在这个时间以后不能在继续使用本地缓存,而需要向服务器发出新的访问请求.

  Expires头字段的设置值应该为GMT格式时间.

  ```
  Expires:Mon,18 Nov 2013 19:01:51 GMT
  ```

  由于浏览器的兼容问题,在设置网页不缓存时,一般将Pragma,Cache-Control,Expires三个字段一起使用;

- Last-Modified

  指定文档最后的更改时间,设置值为GMT格式的时间.当客户端接收到Last-Modified头字段后,它将在以后的请求消息中发送一个If-Modified-Since请求消息头来指出缓存文档的最后更新时间,也就时Last-Modified响应头中的时间,就是下次请求消息中If-Modified-Since请求字段头指定的时间.

  ​

# Servlet

### 简介

随着Web应用业务需求的增多,动态Web资源的开发变得越来越重要.目前,很多公司都提供了开发动态Web资源的相关技术,其中比较常见的有ASP,PHP,JSP和Servlet等.基于Java的动态Web资源开发,Sun公司提供了Servlet和JSP两种技术

### 创建Servlet对象

#### 实现 Servlet接口

```
public class MyGenericServlet implements Servlet {
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}

```

- void init(ServletConfig config)

负责Servlet初始化工作.容器在创建号Servlet对象后,就会调用此方法.该方法接受一个ServletConfig类型的参数,Servlet容器通过这个参数向Servlet传递初始化配置信息

- ServletConfig getServletConfig()

返回容器调用init(ServletConfig config)方法时传递给Servlet的ServletConfig对象,系统自行

- String getServletInfo()

返回一个字符串,其中包含关于Servlet的信息.例如,作者,版本,和版权信息等

- void service(ServletRequest request,ServletResponse response)

负责响应用户请求,当容器接受到客户端访问Servlet对象的请求时,就会调用此方法.容器会构造一个表示客户端请求信息的ServletRequest对象和一个响应客户端的ServletResponse对象作为参数传递给service()方法.在service()方法中,可以通过ServletRequest对象得到客户端的相关信息和请求信息,在对请求进行处理后,调用ServletResponse对象的方法设置响应信息.

- void destroy()

负责释放Servlet对象占用的资源.当Servlet对象被销毁时,容器会调用此方法.

#### 继承Servlet对象实现Servlet方法

由于直接实现Servlet接口来编写Servlet很不方便,需要实现很多方法.

- 因此可以通过继承Servlet接口的实现类javax.servlet.GenericServlet来实现

```
public class MyGenericServlet extends GenericServlet{
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

    }
}

```

MyGennericServlet继承GenericServlet后,只实现了service()方法.这是因为GenericServlet类除了Servlet接口的service()方法外,其他方法都已经实现.由此可见.继承GenericServlet比实现Servlet接口更加简便.

- 通过继承Servlet接口的实现类javax.servlet.http.HttpServlet来实现

它是GenericServlet的子类,专门用于创建应用与HTTP大的Servlet.

```
@WebServlet(name = "Servlet")
public class MyHttpServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }
}

```

**HttpServlet主要有两大功能**

1. 根据用户的请求方式的不同,定义相应的doXXX()方法处理用户请求.如,与GET请求方式对应的doGet()方法,

   与POST方式对应的doPost()方法.

2. 通过service方法将HTTP请求和响应分别转为HttpServletRequest和HttpServletResponse类型对象

需要注意的是,由于HttpServlet类在重写的service()方法中,为每一种HTTP请求方式都定义了对应的doxxx()方法,因此,当定义的类继承HttpServlet后,只需根据请求方法,重写对应的doxxx()即可,不需要重写service()方法.

### Servlet的映射

```
<servlet>
    <servlet-name>Myhttpservlet</servlet-name>
    <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>Myhttpservlet</servlet-name>
    <url-pattern>/myhttpservlet</url-pattern>
</servlet-mapping>
```

上面的配置信息中,元素<servlet>用于注册Servlet,它的两个元素<servlet-name>和<servlet-class>分别指定Servlet名称及其完整类名

元素<servlet-mapping>用于映射Servet对外访问的虚拟路径,它的子元素<servlet-name>必须和<servlet>中的<servlet-name>相同,元素<url-pattern>则是用于指定访问该Servlet的虚拟路径,该路径以"/"开头,代表当前的Web应用的根目录

#### Servlet的多重映射

Servlet的多重映射指的是同一个Servlet可以被映射成多个虚拟路径.也就是说,客户端可以通过多个路径对同一个Servlet进行访问.

- 配置多个<servlet-mapping>元素

  ```
      <servlet>
          <servlet-name>Myhttpservlet</servlet-name>
          <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
          <load-on-startup>1</load-on-startup>
      </servlet>
      <servlet-mapping>
          <servlet-name>Myhttpservlet</servlet-name>
          <url-pattern>/myhttpservlet01</url-pattern>
      </servlet-mapping>
      <servlet-mapping>
          <servlet-name>Myhttpservlet</servlet-name>
          <url-pattern>/myhttpservlet02</url-pattern>
      </servlet-mapping>
  ```

- 在<servlet-mapping>元素中配置多个<url-pattern>子元素

  ```
      <servlet>
          <servlet-name>Myhttpservlet</servlet-name>
          <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
          <load-on-startup>1</load-on-startup>
      </servlet>
      <servlet-mapping>
          <servlet-name>Myhttpservlet</servlet-name>
          <url-pattern>/myhttpservlet01</url-pattern>
          <url-pattern>/myhttpservlet02</url-pattern>
      </servlet-mapping>
  ```

#### Servlet映射路径中使用通配符

有时候,我们希望某个目录下的所有路径都访问同一个Servlet,这时,可以在Servlet映射的路径中使用通配符"*"

- 格式为"\*.扩展名",例如"\*.do"匹配以".do"结尾的所有URL地址
- 格式为"/\**" ; 例如"abc/*\*"匹配以abc开始的所有URL地址

**注意**

两种格式不能混合使用

#### 自动加载Servlet程序

有时候,我们希望某些Servlet程序可以在Tomcat启动是随机启动.例如,当启动一个Web项目时,首先需要对数据库信息进行初始化.

那么可以在Web.xml文件中映射Servlet时,添加<servlet>的一个子元素<load-on-startup>

在<load-on-startup>元素中,其值必须是一个整数.如果这个值是一个负数,或者没有设定这个元素,Servlet容器将在客户端首次请求这个Servlet时加载它;如果这个值是正整数或0,Servlet容器将在Web应用启动时加载并初始化Servlet.

值越小,它对应的Servlet就越被优先加载

```
<servlet>
    <servlet-name>Myhttpservlet</servlet-name>
    <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>Myhttpservlet</servlet-name>
    <url-pattern>/myhttpservlet</url-pattern>
</servlet-mapping>
```

#### 

### Servlet的生命周期



![Servlet的声明周期](E:\笔记\JavaWeb\photo\Servlet的声明周期.jpg)



根据功能的不同,大致可以将Servlet的生命周期分为三个阶段,分别是**初始化阶段**,**运行阶段**,和**销毁阶段**

- 初始化阶段

  当客户端向Servlet容器发出HTTP请求要求访问Servlet时,Servlet容器首先会解析请求,检查内存中是否已经有了该Servlet对象,如果有直接使用该Servlet对象,如果就创建Servlet实例对象,然后通过调用init()方法实现Servlet的初始化工作,需要注意的是,在Servlet的整个生命周期内,它的init()方法只被调用一次

- 运行阶段

  这是Servlet声明周期中最重要的阶段,在这个阶段,Servlet容器会为这个请求创建代表HTTP请求的ServletRequest对象和代表HTTP响应的ServletResponse对象,然后将它们作为参数传递给Servlet的service()方法.service()方法从ServletRequest对象中获取客户请求信息和处理该请求,通过ServletResponse对象生成响应结果.在Servlet的整个生命周期内,对于Servlet的每次访问请求,Servlet容器都会调用一次Servlet的service()方法,并且创建新的ServletRequest和ServletResponse对象,也就是说,service()方法在Servlet的整个生命周期终会被调用多次.

- 销毁阶段

  当服务器关闭或Web应用被移除容器时,Servlet随着Web应用的销毁而销毁.在销毁Servlet之前,Servlet容器会调用Servlet的destory()方法,以便让Servlet对象释放它所占的资源.在Servlet的整个生命周期中,destroy()方法也只被调用一次.



# ServletConfig

### 简介

在Servlet运行期间,经常需要一些辅助信息,例如,文件使用的编码,使用Servlet程序的公司等,这些信息可以在web.xml文件使用一个或多个<init-param>元素进行配置.当Tomcat初始化一个Servlet时,会将该Servlet的配置信息封装到一个ServletConfig对象中,通过调用init(ServletConfig config)方法将ServletConfig对象传递给Servlet.

```
   <servlet>
        <servlet-name>Myhttpservlet</servlet-name>
        <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
        <init-param>
            <param-name>初始化参数名</param-name>
            <param-value>初始化参数值</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>Myhttpservlet</servlet-name>
        <url-pattern>/myhttpservlet01</url-pattern>
    </servlet-mapping>
```

### ServletConfig常用方法

- String getInitParameter(String name)

  根据初始化参数名返回对应的初始化参数值

- Enumeration getInitParameterNames()

  返回一个Enumeration对象,包括所有的初始化参数名

- ServletContext getServletContext

  返回代表Web应用的ServletContext对象

- String getServletName()

  返回Servlet的名字,即web.xml中<servlet-name>元素的值

# ServletContext

### 简介

当Servlet容器启动时,会为每个Web应用创建一个唯一的ServletContext对象代表当前Web应用,该对象不仅封装了当前Web应用的所有信息,而且实现了多个Servlet之间的数据共享.

### 配置Web应用的初始化参数

```
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0"
         metadata-complete="true">
<context-param>
    <param-name>参数名</param-name>
    <param-value>参数值</param-value>
</context-param>
</web-app>
```

### 获取Web应用的初始化参数

- Enumeration getInitParameterNames()

  得到包含所有初始化参数名的Enumeration对象

- String getInitParameter(String name) 

  根据参数名获取参数值

### 多个Servlet对象共享数据

由于一个Web'应用中所有Servlet共享同一个ServletContext对象,因此ServletContext对象的域属性可以被该Web应用中的所有Servlet访问.在ServletContext接口中定义了分别用于增加,删除,设置ServletContext域属性的4个方法.

- Enumeration getAttributeNames()

  返回一个Enumeration对象,该对象包含所有存放在ServletContext中的所有域属性名

- Object getAttbute(String name)

  根据参数指定的属性名返回一个与之匹配的域属性值

- void removeAttribute(String name)

  根据参数指定的域属性名,从ServletContext中删除匹配的域属性

- void setAttribute(String name,Object obj)

  设置ServletContext的域属性,其中name时域属性名,obj时域属性值

#### 注意

ServetContext的数据是全局,共享的.

也就是说一个客户端对数据的修改,对另外其他客户端而言是已知的

所以一般不在ServletContext进行数据的传递

# 请求和响应

### 简介

Servlet最主要的作用就是处理客户端请求,并向客户端做出响应.为此,针对Servlet的每次请求,Web服务器在调用service()之前,都会创建两个对象,分别时HttpServletRequest和HttpServletResponse.

其中,HttpServletRequest用于封装HTTP请求消息,简称request对象.

HttpServletResponse用于封装HTTP响应消息,简称response对象.

![客户端访问Servlet流程图](E:\笔记\JavaWeb\photo\客户端访问Servlet流程图.jpg)



### HttpServletResponse对象

在Servlet API中,定义了一个HttpServletResponse对象,它继承自ServletResponse,专门用来封装HTTP响应消息.由于HTTP响应消息分为**状态行**,**响应消息头**,**消息体**三部分,因此,在HttpServletResponse接口中定义了向客户端发送响应状态码和响应消息头,响应消息体的方法.

#### 发送状态码的相关方法

- setStatus(int status)

  该方法用于设置HTTP响应消息的状态码,并生成响应状态行.由于响应状态行中的状态描述信息直接与状态码相关,而HTTP版本有服务器确定,因此,只要通过setStatus(int status)方法设置了状态码,即可实现状态行的发送.

  正常情况下,Web服务器会默认产生一个200的状态行.

- setError(int sc)

  发送表示错误信息的状态行,例如,404状态码表示找不到客户端请求的资源.

- setError(int sc,String message)

  附加一条用于提示说明的文本信息,该文本信息将出现在发送给客户端的正文内容中

#### 发送响应消息头的相关方法

- void addHeader(String name,String value)

  void setHeader(String name,String value)

  这两个方法都是用来设置HTTP的响应头字段,其中,参数name用于指定响应头字段的名称,参数value用于指定响应头字段的值.不同的是,addHeader()方法可以增加同名的响应头字段,而setHeader()会覆盖同名的前头字段

- void addIntHeader(String name,int value)

  void setIntHeader(String name,int value)

  这两个方法专门用于设置包含整数的响应头.避免了使用addHeader()和serHeader()方法时,需要将int类型的设置值转换为String类型的麻烦

- void setContentLength(int length)

  该方法用于设置相应消息的实体内容的大小,单位为字节.对于HTTP来说,这个方法就是设置了Content-Length响应头字段的值

- void setContentType(String type)

  该方法用于设置Servlet输出内容的MIME类型,对于HTTP来说,就是设置了Content-Type响应头字段的值.

- void setLocale(Locale loc)

  该方法用于设置响应消息的本地化信息.对于HTTP消息来说,就是设置Content-Language响应头字段和Content-Type头字段的字符集编码部分.

- void setCharacterEncoding(String charset)

  该方法用于设置输出内容使用的字符编码,对HTTP来说,就是设置Content-Type头字段中的字符集编码部分.

  如果没有设置Content-Type头字段,setCharacterEncoding方法设置的字符集编码不会出现在HTTP消息的响应头中.

  setCharcterEncoding()方法比setContentType()和setLocale()方法的优先级高.它设置的字符集结果会覆盖setContentType()和setLocale()方法所设置的字符集表

#### 发送响应消息体的相关方法

- getOutputStream()

  该方法所获取的字节输出流对象为ServletOutputStream类型.由于ServletOutputStream时OutputStream的子类,它可以直接输出字节数组的二进制数据.

- getWriter()

  该方法所获取的字符输出流对象为PrintWriter类型.PrintWriter类型的对象可以直接输出字符文本内容

##### 注意

虽然respone对象的getOutputStream()和getWriter()方法都可以发送响应消息体,但是,它们之间相互排斥,不可以同时使用,否则会发送IllegeStateException异常

因为getWriter()方法内部调用了getOutputStream().

#### HttpServletResponse应用

##### 中文输出乱码问题

由于计算机中的数据都是以二进制形式存储的,因此,当传输文本时,就会发生字符和字节之间的转换.字符与字节之间的转换时通过查码表完成的,将字符转换成字节的过程称之为**编码**,将字节转换成字符的过程称之为**解码**,如果编码和解码使用的码表不一致就会导致乱码问题.

由于response对象的字符输出流在编码时,默认采用的是ISO 8859-1的字符码表,该码表不兼容中文.

而浏览器默认采用GB2312码表进行解码,所以必定会造成乱码.

**解决方法**

- 分两部走

1. 指定response存储引擎编码码表

```
response.setChatacterEncoding("utf-8");
```

2. 通知浏览器使用码表解码

```
response.setHeader("Content-Type","text/html;charset=utf-8");
```

- 一步解决

```
response.setContentType("text/html;charset=utf-8");
```

##### 页面定时刷新并跳转

在HTTP中,定义了一个Refresh头字段,它可以通知浏览器在指定时间内自动刷新并跳转到其他页面.

```
response.setHeader("Refresh","2")                    --两秒后进行刷新
response.setHeader("Refresh","2;URL=跳转地址")        --两秒后进行跳转到指定地址
```

##### 禁止浏览器缓存页面

```
response.setDateHeader("Expires",0);
response.setHeader("Cache-Control","no-cache");
response.setHeader("Pragma","no-cache");
```

由于不同浏览器对他们的支持不同,一般在响应消息中将这个三个头字段都设置

##### 请求重定向

为了实现请求重定向,在HttpServletResponse接口中,定义了一个sendRedirect()方法

该方法用于生成302响应码和Location响应头字段,从而通知客户端重新访问Location响应头中指定的URL.

```
response.sendRedirect("/Web应用指定资源");   --"/"表示Web应用根目录
```

### HttpServletRequest对象

 #### 获取请求行信息的相关方法

- String getMethod（）

  获取HTTP请求信息中的请求方式（GET.POST...）

- String getRequestURI（）

  获取请求行中的资源名称部分，即位于URI的主机名和端口号之后，参数部分之前的部分

- String getQueryString（）

  获取请求行中的参数部分，即“?”之后的所有内容

- String getProtocol（）

  获取请求行中的协议名和版本，例如，HTTP1.0或HTTP1.1

- String getContextPath（）

  获取请求URL中属于Web应用程序的路径，这个路径以“/“开头，表示相对域整个Weeb站点的根目录，路径结尾不含”/“。

- String getPathInfo（）

  获取请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以”/“开头。如果没有额外路劲信息部分，返回null

- String getPathTranslated（）

  获取URL中额外路径信息所对应的资源的真实路径。

#### 获取请求消息头的相关方法

- String getHeader（String name）

  获取一个指定头字段的值，如果请求消息中不存在指定的头字段，返回null。如果消息头中包含多个指定的头字段。返回第一个头字段的值。

- Enumeration getHeaders（String name）

  该方法返回一个Enumeration集合对象，该集合对象由请求消息头中出现的某个指定名称的所有头字段值组成

- Enumeration getHeaderNames()

  获取一个包含所有请求头字段的Enumeration对象

- int getIniHeader（String name）

  获取指定名称的头字段值，并将其值转换成int类型。

- long getDateHeader（String name）

  获取指定名称的头字段值，并将其值按GMT时间格式转换成一个代表日期/时间的长整数

- String getContentType（）
  获取Content-Type头字段的值

- int getContentLenth（）

  获取Content-Lenght头字段的值

- String getCharacterEncoding（）

  获取请求消息的实体部分的字符集编码，通常是从Content-Type头字段中提取。

####获取请求消息体的相关方法

- ServletInputStream getInputStream（）

  获取表示实体内容的ServletInputStream对象，如果实体内容为非文本，那么只能通过getInputStream（）方法获取请求消息体

- BufferedReader getReader（）

  获取实体内容的BufferedReader对象，该对象会将实体内容中的字节数据按照请求消息中指定的字符集编码转换成文本字符串。

  也可使用setCharacterEncoding（）方法指定BUfferedReader对象所使用的字符编码。

  如果请求消息没有指定字符集编码，而BufferedReader又没指定字符集编码，那么将默认采用ISO-8859-1

#### HttpServletRequest应用

##### 获取请求参数

- String getParameter（String name）

  获取指定名称的参数值

  如果请求消息中没有存在指定名称的参数，返回null

  如果存在指定名称的参数，但没有设置值，返回”“

  如果存在多个指定名称的参数，返回第一个参数值

- String 【】 getParameterValues（String name）

  获取同一参数名对应的所有参数值

- Enumeration getParameterNames（）

  返回请求消息中的所有参数名的Enumeration对象

- Map getParameterMap（）

  将请求消息中的参数名和参数值封装到一个Map集合

##### 请求参数中文乱码问题

浏览器在传递请求参数时，默认采用的编码方式时GBK，但在解码时采用的是默认的ISO-8869-1，因此出现了参数信息乱码问题

**解决方法**

```
request.setCharacterEncoding("utf-8");  --设置request对象的解码方式
```

**但仅对POST方式有效**

因为setCharacterEncoding（）方法仅对实体内容数据设置有效

而GET方式请求中的参数是附加到请求行内，因此方法对GET方式无效

**GET解决方法**

- 使用错误码表再次编码后在使用正确码表解码

  ```
  name=new String(name.getBytes("错误码表"),"正确码表")
  ```

##### 获取网络连接信息

- String getRemoteAddr（）

  获取请求客户端的IP地址

- String getRemoteHost（）

  获取请求客户端的完整主机名

- int getRemotePort（）

  获取请求客户端网络连接的端口号

- 。。。

##### 通过Request对象传递数据

- setAttribute(String name,Object obj)

  将一个对象与一个名称关联后存储进ServletRequest对象

  如果已存在就覆盖原有值

- getAttribute（String name）

  从ServletRequest对象中获取指定名称的属性对象

- removeAttribute（String name）

  从ServletRequest对象中删除指定名称的属性对象

- getAttributeNames（）

  返回一个包含ServletRequest对象中所有属性名的Enumeration对象

######注意

只属于同一次请求中的数据才可以通过ServletRequest对象传递数据

##### RequestDispatcher对象的应用

当一个Web资源收到客户端的请求后，如果希望服务器通知及另外一个资源去处理请求，除了使用sendRedirect（）方法让**客户端去实现请求重定向外**，还可以通过RequestDispatcher接口的实例对象来让**服务器端实现请求转发**

###### 步骤

1. 获取RequestDispatcher对象

- RequestDispatcher getRequestDispatcher（String path）

  返回封装了某个路径所指资源的RequestDispatcher对象。

  其中，参数path必须以"/"开头，用于表示当前Web应用的根目录

2. 通知其他Web资源处理当前Servlet请求

- forward（ServletRequest request，ServletResponse response）

  将请求从一个Servlet传递给另外一个Web资源。最后由它发送响应消息

- include（ServletRequest request，ServletResponse response）

  将其他的资源作为当前响应内容包含进来

  ​

# 会话及其会话技术

### 简介

当用户通过浏览器访问Web应用时，通常情况下，服务器需要对用户的状态进行跟踪。

例如，用户在网站结算商品时，Web服务器必须根据请求用户的身份，找到该用户所购买的商品。

在Web开发中，服务器跟着用户信息的技术称为会话技术。

客户端与Web服务器之间连续发生的一系列请求和响应过程就是一个会话.

例如,一个用户在某网站上整个购物的过程就是一个会话.

### 会话技术保存数据与其他两种的区别

> HttpServletRequest

该对象只能保存本次请求所传递的数据.

> ServletContext

在ServletContext对象保存的数据是共享的,也就是说,某一个客户端对其修改的值,相对其他客户端而言是可见的.

> 会话

为单独的客户端进行数据保存,每个客户端之间的数据彼此分隔

### Cookie

#### 简介

Cookie是一种会话技术,它用于将会话过程中的数据**保存到用户的浏览器本地中**,从而使浏览器和服务器可以更好地进行数据交互.

服务器向客户端发送Cookie时,会在HTTP响应头字段中增加Set-Cookie响应头字段

```
Set-Cookie:Cookie名称=Cookie值;Path=/;Domian="www.jr.com";
```

- Path:表示Cookie的属性

当用于第一次访问服务器时,服务器会在响应消息中增加Set-Cookie头字段,将用户信息以Cookie的形式发送给浏览器.一旦用户浏览器接受了服务器发送的Cookie信息,就会将它保存在浏览器的缓存区中,这样,当浏览器后续访问该服务器时,就会在请求消息中将用户信息以Cookie的形式发送给Web服务器,从而服务器端分辨出当前请求是由哪个用户发出的.

#### Cookie API

**构造方法**

- public Cookie(String name,String value)

>  name:指定Cookie的名称

>  value:指定Cookie的值

**常用方法**

- String getName()

  返回Cookie的名称

- void setValue(String newValue)

  设置Cookie值

- String getValue()

  获取Cookie值

- void setMaxAge(int expiry)

  设置Cookie在浏览器上保持的有效秒数

- int getMaxAge()

  获取Cookie在浏览器上保持的有效秒数

  默认情况下,Cookie对象的Max-Age属性的值时**-1**,即浏览器关闭时,删除这个Cookie对象

  属性值为**0**,即不保存这个Cookie

- void setPath(String uri)

  设置该Cookie项的有效目录路径

  浏览器在访问该有效目录路径时会回送Cookie信息

  如果创建的某个Cookie对象没有设置Path属性,那么该Cookie只对当前访问路径所属的目录及其子目录有效.

  如果想让某个Cookie对站点的所有目录下的访问都有效,应调用Cookie对象的setPath()方法将其Path属性设为"/"

  "/"代表当前Web应用所在目录

- String getPath()

  返回该Cookie项的有效目录路径

- void setDomain(String pattern)

  设置该Cookie项的有效域

  Domain属性的值为当前主机名,浏览器在访问当前主机下的资源时,都会将Cookie信息回送给服务器.

- String getDomain()

  获取该Cookie项的有效域

- void setVersion(int v)

  设置该Cookie采用的协议版本

- int getVersion()

  获取该Cookie采用的协议版本

- void setComment(String purpose)

  设置该Cookie的注解部分

- String getComment()

  获取该Cookie的注解部分

  **使用**

```
Cookie cookie=new Cookie("Cookie名","Cookie值")
response.addCookie(cookie);    //添加到响应头字段
```

​       **响应消息头字段**

```
Set-Cookie:Cookie名=Cookie值; Path=/; 
```

#### 注意

一个站点浏览器只允许存在20个Cookie

### Session

#### 简介

Cookie技术可以将用户的信息保存在各自的浏览器中,并且可以在多次请求下实现数据的共享.

但是,如果传递的信息比较多,使用Cookie技术显然会增大服务器端程序处理的难度.

这时,可以使用Session实现.

**Session是一种将会话数据保存到服务器端的技术**

例如

当我们去医院就诊时,医院都会给就诊病人发放就医卡,卡上只有卡号,而没有其他信息.但是病人每次去该医院就诊时,只要出示就医卡,医务人员便可以根据卡号查询到病人的就诊信息.

Session技术就好比医院发放病人的就医卡和医院为每个病人保留病例档案的过程.

当浏览器访问Web服务器时,Servlet容器就会创建一个Session对象和ID属性,

其中Session对象相当于病例档案,ID相当于就医卡号

后续客户端访问服务器时,只要将标识号传递给服务器,服务器就能判断出该请求是哪个客户端发送的,从而选择与之对应的Session对象为其服务.

**由于客户端需要接受,记录和回送Session对象的ID,因此,通常情况下,Session是借助Cookie技术来传递ID属性的**

#### 利用URL重写实现Session跟踪

前面提到,服务器在传递Session对象的ID属性时,是以Cooklie的形式传递给浏览器的.

但是,如果浏览器的Cookie功能被禁止,那么服务器端是无法通过Session保存用户会话信息的.

考虑到浏览器可能不支持Cookie的情况,Servlet规范种引入了URL重写机制来保存用户的会话信息

所谓URL重写,指的是将Session的会话标识号以参数的形式附加在超链接的URL地址后面.

对于Tomcat服务器来说,就是将JSessionID关键字作为参数名,会话标识号作为参数值附加到URL地址后面

```
String url="资源连接"
HttpSession s=resquest.getSession();
String newURL=response.encodeRedirectURL(url);
resp.sendRedirect(newURL)
```

- 重写前的url

  `/myhttpservlet01?id=jr`

- 重写后的url

  `/myhttpservlet01;jsessionid=2893056D4E449F802FF8461EFF98230C?id=jr`

看出对链接进行URL重写后,URL地址后面跟上了Session的标识号

**注意**

1. 重写URL时,前面要通过getSession()方法获取Session对象

2. 客户端第一次访问Web服务器时,Web服务器程序对URL重写才有效

3. 无论浏览器是否支持Cookie,当用于第一次访问程序时,由于服务器不知道用户的浏览器是否支持Cookie,在第一次的响应的页面中都会对URL地址进行重写,如果用户浏览器支持Cookie,那么在后续访问中都会使用Cookie的请求头字段将Session的标识号传递给服务器.

   由此,服务器判断出该浏览器支持Cookie,以后不在对URL进行重写.

   如果浏览器的头信息不包含Cookie请求头字段,那么在后续的每个响应中都需要对URL进行重写.



#### HttpSession  API

**获取Session对象**

- public HttpSession getSession(boolean create)
- public HttpSession getSession()

两种都是返回当前请求相关的HttpSession对象.

不同的是,第一种方法根据传递的参数来判断是否创建新的HttpSession对象.

如果参数为true,则在相关的HttpSession对象不存在时创建新的HttpSession对象,否则不创建,而返回null

第二张情况相当于第一种情况的参数为true

**常用方法**

- String getId()

  返回与当前HttpSession对象关联的会话标识号

- long getCreationTime()

  返回Session创建时间.

- long getLastAccessedTime()

  返回客户端最后一次发送与Session相关请求的时间

- void setMaxInactiveInterval(int interval)

  设置当前HttpSession对象可空闲的以秒为单位的最长时间

- boolean isNew()

  判断当前HttpSession对象是否时最新创建的

- void invalidate()

  强制使Session对象无效,内部存储的数据随机被清空

- ServletContext getServletContext()

  返回当前HttpSession对象所属于的Web应用程序对象

- void setAttribute(String name,Object value)

  将一个对象与一个名称关联后存储到当前HttpSession对象中

- String getAttribute(String name)

  从当前HttpSession对象中返回指定名称的属性对象

- void removeAttribute(String name)

  从当前HttpSession对象种删除指定名称的属性

  ​

#### Session超时管理

当客户端第一次访问某个能开启会话功能的资源时,Web服务器就会创建一个与该客户端对应的HttpSession对象.在HTTP种,Web服务器无法判断当前浏览器客户端是否还会继续访问,也无法检测浏览器客户端是否关闭,所以,即使客户端已经离开或关闭浏览器,Web服务器都还会保存与之对应的HttpSession对象.随着时间的推移,这些不在使用的HttpSession对象会在Web服务器种积累的越来越多,从而使Web服务器的内存耗尽.

为了解决上面的问题,Web服务器采用了**超时限制**的办法来判断客户端是否还在继续访问.

在一定时间内,如果某客户端一直没有请求访问,那么,Web服务器就会认为该客户端已经结束了请求,并将对应的HttpSession对象变成垃圾,等待垃圾收集器将其从内存中彻底删除.

##### 配置超时时间

在<tomcat安装目录>\conf\web.xml文件中,找到↓配置

```
    <session-config>
        <session-timeout>30</session-timeout>
    </session-config>
```

设置的时间值是以分钟为单位,即Tomcat服务器的默认会话超时间隔为30分钟

如果设置为0或一个负数,则表示会话永不超时.

在Web.xml文件对站点内的所有Web'应用都起作用

要想单独设置某个Web应用程序的会话超时间隔,则需要在自己的应用的web.xml文件进行设置

要想Session失效,除了可以等待会话时间超时外,还可以通过invalidate()方法强制使会话失效

# JSP技术

### 简介

在动态页面开发中,经常需要动态生成HTML内容,例如,一篇新闻报道的浏览次数需要动态生成.

这时,如果使用Servlet来实现HTML页面数据得改变,需要调用大量的输出语句,从而使静态内容和动态内容混合在一起,导致程序非常臃肿.

为了克服Servlet的这些缺点.Sun公司推出了JSP

JSP全名是Java Server Page,它是建立在Servlet规范之上的动态网页开发技术

在JSP文件中,HTML代码与Java代码共同存在,其中HTML代码用来实现网页中的静态内容显示,java代码用来实现网页的动态内容的显示

为了与普通的HTML有所区别,JSP文件的扩展名为.jsp

###JSP运行原理

查看到Tomcat服务器中的web.xml文件可知道

```
    <servlet>
        <servlet-name>jsp</servlet-name>
        <servlet-class>org.apache.jasper.servlet.JspServlet</servlet-class>
        <init-param>
            <param-name>fork</param-name>
            <param-value>false</param-value>
        </init-param>
        <init-param>
            <param-name>xpoweredBy</param-name>
            <param-value>false</param-value>
        </init-param>
        <load-on-startup>3</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>jsp</servlet-name>
        <url-pattern>*.jsp</url-pattern>
        <url-pattern>*.jspx</url-pattern>
    </servlet-mapping>

```

从上面的配置信息可以看出,以.jsp为扩展名的URL访问请求都是由org.apache.jasper.servlet.JspServlet处理

所以,Tomcat中的JSP引擎就是一个Servlet程序,该Servlet程序实现了所有JSP页面的解析.

需要注意的是,JSP文件也可以想Servlet程序一样,在web.xml文件中进行注册和映射虚拟路径.注册JSP页面的方式和Servlet类似

**只需要将<servlet-class>元素修改为<jsp-file>元素即可**

```
    <servlet>
        <servlet-name>jsp_servlet</servlet-name>
        <jsp-file>/index.jsp</jsp-file>             --"/"表示Web应用的根目录
    </servlet>
    <servlet-mapping>
        <servlet-name>jsp_servlet</servlet-name>
        <url-pattern>/jsp_servlet</url-pattern>
    </servlet-mapping>
```

1. **翻译编码**

当用户第一次访问JSP页面时,该页面都会被org.apache.jasper.servlet.JspServlet翻译成一个Servlet源文件(.java),

然后将源文件编译成class文件.Servlet源文件和.class文件都放在"Tomcat安装目录/work/Catalina/localhost/应用名/"目录下.

由JSP文件翻译成的Servlet类带有包名,包名为org.apache.jsp

因此完整的文件路径是:Tomcat安装目录/work/Catalina/localhost/应用名/org/apache/jsp/jsp文件名_jsp.class

```
public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private volatile javax.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
    if (_el_expressionfactory == null) {
      synchronized (this) {
        if (_el_expressionfactory == null) {
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        }
      }
    }
    return _el_expressionfactory;
  }

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
    if (_jsp_instancemanager == null) {
      synchronized (this) {
        if (_jsp_instancemanager == null) {
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        }
      }
    }
    return _jsp_instancemanager;
  }

  public void _jspInit() {
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write('\n');
      out.write("\n");
      out.write("\n");
      out.write("<html>\n");
      out.write("<head>\n");
      out.write("    <title>$Title$</title>\n");
      out.write("</head>\n");
      out.write("<body>\n");
      out.write("当前的时间是：\n");

    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));

      out.write("\n");
      out.write("\n");
      out.write("</body>\n");
      out.write("</html>\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}

```

其中静态页面的HTML输出代码和JAVA动态代码都放在了_jspService()方法内

2. **JspServlet将请求转发到编译后的JSP对应的Servlet,然该Servlet响应请求**.



### JSP语法

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>
当前的时间是：
<%
    //Java代码
    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));
%> 
</body>
</html>
```

**运行输出**

![JSP技术](E:\笔记\JavaWeb\photo\JSP技术.bmp)

#### JSP表达式

JSP表达式用于将程序数据输出到客户端或赋值到参数值上,它将要输出的变量或者表达式直接封装在以

<%=java返回值函数%>标记中

```
<%=new Date().toLocaleString()%>
```

#### JSP脚本片段

JSP脚本片段是指嵌套在<%和%>之中的一条或多条程序代码,这些Java代码必须严格遵守Java语法规范,否则会编译报错。

```
<%
    //Java代码
    out.write("当前时间:");
%> 
<%
    //Java代码
    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));
%> 
```

单个脚本片段的Java语句可以是不完整的，但是，多个脚本片段组合后的结果必须是完整的Java语句。

因为脚本片段的Java代码将原封不动地移到JSP页面所翻译的Servlet的_jspService()方法中。

```
<% int i=1 %>
<% while(i=1) %>
<% 
{
    out.write("helloworld");
}
%>
```



#### JSP声明

当JSP页面被翻译成Servlet程序时，JSP中包含的脚本片段，表达式，模板元素都将转换为Servlet中的_jspService()方法的程序代码。

这时，JSP脚本片段中定义的变量都将称为_jspServce()方法中的局部变量，而JSP脚本片段中定义的方法都将插入

_jspService()方法，从而出现在程序的方法中再定义方法，这样的语法时错误的。

为了解决这样的问题，在JSP技术中提供了声明,

如↓

```
<%! 
Java代码
%>
```

被声明的Java代码都将翻译到Servlet的_jspService()方法值外。

同脚本片段一样，在Jsp页面中也可以由多个JSP声明，单个声明中的Java语句可以时不完整的，但是多个声明组合后的结果必须是完整的Java语句。

#### JSP注释

```
<%-- 注释信息 --%>
```

Tomcat在将JSP页面翻译成Servlet程序时,会忽略JSP页面中被注释的内容,不会将注释的信息发送到客户端



### JSP指令

为了设置JSP页面中的一些信息,SUN公司提供了JSP指令.

JSP2.0中定义了**page**,**include**,**taglib**三种指令.

每一种指令都定义了各自的属性

#### page指令

在JSP页面中,经常需要对页面的某些特性进行描述,例如,**页面的编码方式**,**JSP页面采用的语言**,**类库的引用**...

这时就可以通过page指令来实现

**语法格式**

```
<%page 属性名="属性值" %>
```

**常用属性**

- language

  ```
  <%page language="java" %>
  ```

  指明解释该JSP文件时采用的语言,默认为java

- extends

  ```
  <%page extends="任何类的全名" %>
  ```

  指明编译该JSP文件时继承哪个类

  JSP为Servlet,因此当 指明继承普通类时需要实现Servlet的init(),destory()方法,**一般不会去继承**

- import

  ```
  <%page import="任何包名,类名" %>
  ```

  指定在JSP页面翻译成Servlet源文件中导入的包或类

- session

  ````
  <%page session="true|false" %>
  ````

  指明该JSP内是否内置Session对象.如果为true,则说明内置Session对象,可以直接使用.默认为true

- autoFlush

  ```
  <%page autoFlush="true|false" %>
  ```

  指明是否运行缓存,如果为true,使用out.println()等方法输出的字符串并不立刻到客户端服务器,而是暂时存在缓冲区里,缓存满或者程序执行完毕或者执行out.flush()等操作才会到客户端,

  如果autoFlush=false,那么JSP输出的内容需要自行调用out.flush()方法,将内容输出到response缓存区,不然知道JSP程序结束之后才输出到response.

  默认情况下,autoFlush为true

- buffer

  ```
  <%page buffer="none|数值+kb" %>
  ```

  指定缓存的大小,当autoFlush设为true时才有效

  none=0kb

- isThreadSafe

  ```
  <%page isThreadSafe="true|false" %>
  ```

  指定线程是否安全,如果为**true**,则**多个线程**同时运行该jsp程序,否则只运行**一个线程**,其他线程等待

  默认情况下,isThreadSafe=true

- isErrorPage

  ```
  <%page isErrorPage="true|false" %>
  ```

  指定该页面是否为错误处理页面,如果为true,则该JSP页面内容有一个Exception对象的exception,可以直接使用.默认情况下,isErrorPage=false

- errorPage

  ```\
  <%page errorPage="某个JSP页面的相对路径" %>
  ```

  指定一个错误页面,如果该JSP程序抛出一个未捕获的异常,则转到errorPage指定的页面.error-Page指定的页面的isErrorPage属性为true,且内置的exception对象为未捕获的异常

- contentType

  ```
  <%page contentType="有效的文档类型" %>
  ```

  客户端浏览器根据该属性判断文档类型.例如:

  HTML格式为:text/html

  JPG图像为:image/jpeg

- info

  ```
  <%page info="任何字符串" %>
  ```

  指定JSP的信息,该信息可以通过Sevlet.getServletInfo()方法获取到

  ​

#####应用

**autoFlush(是否将输出内容自动输入到JSP缓存区)**

![out隐式对象的工作原理](E:\笔记\JavaWeb\photo\out隐式对象的工作原理.bmp)

JSP向客户端输出内容,如果设定了autoFlush=true和buffer=缓存值得话

输出内容不会直接输出到response缓存区,而输出到JSP引擎自带的缓存区

**待缓存取满了**或**程序运行结束**在或者调用**out.flush()方法**

才会将内容输出到response缓存区,最后response缓存区的内容才会发送给客户端.

> autoFlush=true , buffer=10kb

```
<%@ page contentType="text/html;charset=UTF-8" language="java"  buffer="10kb" autoFlush="true" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>

<%

    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));
    response.getWriter().write("当前的时间是：");
%>
</body>
</html>
```

![out隐式对象的工作原理02](E:\笔记\JavaWeb\photo\out隐式对象的工作原理02.bmp)

因为response.getWriter().write("")方法是直接将输出内容输入到response缓存区,

而JSP的out隐式对象是将输出内容输入到JSP引擎自带的缓存区,**待缓存区满了**或**自行调用out.flush()**在或者**程序结束后**才将输出内容输入到resopnse缓存区.

因此服务端向客户端输出的内容中**response.getWriter().write("")的输出内容**比**JSP中的out隐式对象输出的内容**先输出.

> autoFlush=true , buffer=0kb

```
<%@ page contentType="text/html;charset=UTF-8" language="java"  buffer="0kb" autoFlush="true" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>

<%

    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));
    response.getWriter().write("当前的时间是：");
%>
</body>
</html>
```

![out隐式对象的工作原理01](E:\笔记\JavaWeb\photo\out隐式对象的工作原理01.bmp)

当autoFlush=true时,JSP输出内容会当缓存区buffer满时,自动刷新到response

因为buffer缓存区的大小为0kb,所以JSP的隐式对象out输出的内容会直接输入到response缓存区

因此服务端向客户端输出的内容中***JSP中的out隐式对象输出的内容***比**response.getWriter().write("")的输出内容**先输出.

- errorPage指定错误页面

> 未指定错误页面,出现异常时

```
<%@ page contentType="text/html;charset=UTF-8" language="java"  buffer="none" autoFlush="true"  %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>

<%
    response.getWriter().write("HelloWrold：");//输出内容
    String s=null;                             //对象为nulll
    s.getBytes();		                      //调用null对象方法
    response.getWriter().write("HelloWrold：");//输出内容
%>
</body>
</html>

```

![errorPage01](E:\笔记\JavaWeb\photo\errorPage01.bmp)

**异常出现后,不在向客户端输出内容**

> 指定错误页面,出现异常时

```
<%@ page contentType="text/html;charset=UTF-8"  language="java"  errorPage="/errorPage.jsp" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>

<%
    response.getWriter().write("HelloWrold：");
    String s=null;
    s.getBytes();
    response.getWriter().write("HelloWrold：");
%>
</body>
</html>

```

![errorPage02](E:\笔记\JavaWeb\photo\errorPage02.bmp)

**JSP页面出现异常后,异常页面转发给错误页面执行**

------

如果为每一个页面都指定一个错误页面,这样的做法显然很烦琐,这时,可以在web.xml文件中使用<error-page>元素

为整个Web应用程序设置错误处理页面

```
    <error-page>
        <error-code>500</error-code>
        <location>/errorPage.jsp</location>
    </error-page>
```

error-code:错误响应状态码

location:错误处理页面



#### include指令

有时候,需要在JSP页面静态包含一个文件,例如HTML文件,文本文件等,这时,可以通过include指令来实现

```
    <%@include file="URL"%>
```

- 被引入的文件必须遵行JSP语法,其中内容可以包括静态HTML,JSP脚本元素和JSP指令等普通JSP页面所具有的一切内容
- 除了指令元素外,被引入的文件中的其他元素都被转换成响应的Java源代码,然后插入进当前JSP页面所翻译成的Servlet源文件中,插入位置与include指令在当前JSP页面的位置保持一致

**也就是说include指令包含的内容是编译时包含**

查看到JSP页面翻译成的Servlet文件中的_jspService()方法中的一段输出内容代码可知

**JSP元文件**

```

```

**翻译的Servlet文件**

```
      out.write('\n');
      out.write("\n");
      out.write("\n");
      out.write("<html>\n");
      out.write("<head>\n");
      out.write("    <title>$Title$</title>\n");
      out.write("</head>\n");
      out.write("<body>\n");
      out.write("\n");
      out.write("\n");

    out.write("HelloWrold");
      out.write('\n');
      out.write("\r\n");
      out.write("\r\n");
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("    <title>错误页面</title>\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");

    out.write("抱歉，服务器出现异常");

      out.write("\r\n");
      out.write("</body>\r\n");
      out.write("</html>\r\n");
      out.write('\n');

    out.write("HelloWrold");
      out.write("\n");
      out.write("</body>\n");
      out.write("</html>\n");

```

#### taglib指令

在进行自定义标签开发中,如果某个JSP文件想使用到该自定义标签的话,就需要导入该标签

其中taglib指令就是导入自定义标签的指令

```
<%@taglib uri="tld文件中url映射路径" prefix="前缀"%>
```

**uri:**在tld文件中的url映射路径

**prefix:**标签前缀.如\<jsp:forward/>中的jsp,一般定义为tld文件名,这样的话比较容易找到对应的自定义标签

**什么是tld文件**

tld:英文全称Tag Library Description,标签库描述文件.声明自定义标签的文件,通过该文件可以映射到自定义标签所对应的类对象,从而调用该对象方法



### JSP隐式对象

在JSP页面中,有一些对象需要频繁使用,如果每次创建这些对象则会非常麻烦.

为此,JSP提供了9个隐式对象,它们是JSP默认创建的,可以直接在JSP页面使用.

- **JspWriter**    out

  用于页面输出,

  **注意的是**,输出对象不同于response输出,JspWriter输出的内容先会输入到自身缓存区

  **待缓存区满了**,或**刷新缓存区**,在者**程序执行结束**后才会将输出内容输入到response缓存区.

  response最终待响应结束将内容response缓存区的内容输出给客户端

- **HttpServletRequest**      request

  得到用户请求信息

- HttpServletResponse       response

  服务器向客户端的回应信息

- **ServletConfig**         config

  服务器配置,可以取得初始化参数

- **HttpSession**        session

  用来保存用户信息

- **ServletContext**       application

  所有用户的共享信息

- **PageContext**          pageContext

  JSP的页面容器

- **Objcect **        page

  指当前页面装换后的Servlet类的实例

- **Throwable**        exception

  表示JSP页面所发生的异常,只在错误页面中才起作用.也就是isErrprPage=true时.

  ​

 

#### PageContext对象

在JSP页面中,要想获取JSP的隐式对象,还可以使用pageContext对象.它代表当前JSP页面的运行环境,并提供了一系列获取其他隐式对象的方法.

该对象在做自定义标签时可以方便的获取其他隐式对象,并调用其方法

```

```

![pageContext](E:\笔记\JavaWeb\photo\pageContext.bmp)

##### PageContext对象的应用

> pageContext存储数据

pageContext对象不仅提供了获取隐式对象的方法,还提供了存储数据的功能.

pageContext对象存储数据是通过操所属性来实现的

- void setAttribute(String name,Object value,int scope)

  设置pageContext对象的属性

- Object getAttribute(String name,int scope)

  获取pageContext对象的属性

- void removeAttribute(String name,int scope)

  删除指定范围内名称为name的属性

- void removeAttribute(String name)

  删除所有范围内名称为name的属性

- Object findAttribute(String name)

  从四个域对象中查找名称为name的属性

**域对象**

- pageContext.PAGE_SCOPE:表示页面范围


- pageContext.REQUEST.SCOPE:表示请求范围


- pageContext.SESSION.SCOPE:表示会话范围

- pageContext.APPLICATION.SCOPE:表示Web应用程序范围

  ​

当使用findAttribute()方法查找名称为name的属性时,会按照page,requset,session,application(ServletContext)

范围从小到大查找,如果找到返回属性名称的值,停止查找.否则返回null.



### 原生JSP标签

JSP页面中可以嵌套一些java代码来完成某种功能,但是这种java代码会使JSP页面很乱,不利于美工调试和维护.

为了减少JSP页面中的Java代码,Sun公司允许在JSP页面中嵌套一些标签,这些标签可以完成各种通用的JSP页面功能,

被称为JSP标签.

#### <jsp:include>标签

在JSP页面中,为了吧其他资源的输出内容插入到当前JSP页面的输出内容中,JSP技术提供了\<jsp:include\>标签

**语法格式**

```
<jsp:include page="引用资源相对路径" flush="true|false">
```

page:指定被引入资源的相对路径

flush:指定当前页面的输出内容是否刷新到客户端,默认情况下,flush=false

**flush=true:**include标签之前输出的内容不等待include标签中引用的资源执行输出,而先输出到客户端

**flush=false:**include标签之前输出的内容等待include标签中引用的资源执行输出,待引用资源中的程序执行结束后,一块输出到客户端.



#####  <jsp:include>标签与include指令的区别

- include标签中引入的资源和当前JSP页面是两个彼此独立的执行实体,即被动态引入的必须能够被Web容器独立执行.

  而include指令只能引用遵循JSP格式的文件,被引入的文件与JSP文件需要共同合并才能翻译成一个Servlet源文件

- include标签中引用的资源是在运行才包含的,而且只包含运行结构

  include指令引入的资源实在编译时期包含的,包含的是源代码

- include标签运行原理与RequestDispatcher.include方法类似,即被半酣的页面不能改变响应状态码或者设置响应头,而include指令没有这方面的限制



#### <jsp:forward>标签

在JSP页面中,经常需要将请求转发给另外一个资源,这时,除了RequestDispatcher接口的forward()方法可以实现外,还可以通过<jsp:forward>标签来实现.

```

```

查看翻译后的Servlet源文件后,可知

<jsp:forward>标签被翻译成了调用pageContext.forward方法的语句,并在调用pageConext.forward()方法后使用return语句结束了service()方法的执行流程,从而不在执行<jsp:forward>标签后面的语句.



### 自定义JSP标签















































