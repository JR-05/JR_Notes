# 互联网常见协议

​       **协议**         **工作端口**

- http           80         
- smtp         25
- pop3         110
- ftp              23
- https          443

# Tomcat启动失败原因

- JAVA_HOME环境未配置

由于Tomcat依赖于java环境，所以Tomcat找不到JDK环境，就启动不了Tomcat

- 端口被占用
- Catalina_home环境变量的设置问题

Catalina_home环境变量：配置Tomcat位置

startup.bat（启动Tomcat），首先会在环境变量中启动Catalina_home配置中的Tomcat。所以，如果你配置了Catalina_home的话，在本地盘中有多个Tomcat服务器，假若你运行的是C盘中的startup.bat，但你Catalina_home配的是D盘的Tomcat，则它启动的D盘的Tomcat。



# Tomcat目录结构

- bin                            存放启动和关闭Tomcat等的脚本文件
- conf                          存放Tomcat的各种配置文件(如配置Tomcat运行端口的server.xml文件)
- lib                              存放Tomcat支持的jar包
- logs                           存放Tomcat的日志文件（如Tomcat黑窗口中的输出信息）
- temp                         存放Tomcat运行是产生的临时文件。对于WEB开发者来说不必关心，只供Tomcat服务器开发者有用
- webapps                  存放Web开发的应用，即供外界访问的Web资源存放目录
- work                         Tomcat的工作目录，如Tomcat在运行中将JSP转换成Servlet代码，这些Servlet代码就存放在工作目录中



# WEB应用的组成结构

- Web应用名					                           WEB应用所在目录
- html,jsp,css,js文件等                                       这些文件一般存在Web应用根目录下，根目录下的文件外界可以直接访问
- Web应用根目录/WEB-INF                                java类，jar包，web应用的配置文件,标签库描述文件等存在这个目录下，该目录下的文件外界无法直接访问，有web服务器负责调用
- Web应用根目录/WEB-INF/classes                  java类
- Web应用根目录/WEB-INF/lib                          jar包
- Web应用根目录/WEB-INF/web.xml               WEB应用配置文件

# 虚拟目录的映射

**WEB应用:**  WEB应用程序指供浏览器访问的程序，通常称为WEB应用

**WEB目录：**存放WEB应用程序的目录，称之为WEB目录

**虚拟目录的映射:** WEB应用开发好后，若想供外界访问，需要将WEB目录交给WEB服务器管理，这个过程称之为虚拟目录的映射。



### 虚拟目录映射方式

- 在conf\server.xml目录下配置<Context/>

```
<Context path="/外界访问的虚拟目录"  docBase="WEB目录"/>
```

**特点**：加入WEB服务器（Tomcat）在C盘，而开发的工作环境目录在D盘，那么就可以通过这种方式，直接将D盘的WEB应用目录映射到Tomcat中。**但需要重启Tomcat。**

- 在conf\Catalina\localhost下创建**文件名.XML**，在XML文件下配置<Context/>

1. 文件名：外界访问的虚拟目录
2. 文件下配置

**技巧：**如果需要进行多级的虚拟目录（即：localhost:8080**/a/b/c**）,那么可通过取文件名的时候在每级目录名用”#“进行分割

如：创建一个多级目录localhost:8080**/a/b/c**，则文件名就是：a#b#c.xml

**特点**：加入WEB服务器（Tomcat）在C盘，而开发的工作环境目录在D盘，那么就可以通过这种方式，直接将D盘的WEB应用目录映射到Tomcat中。**无需重启Tomcat。**

```
<Context docBase="WEB目录"/>
```

- 直接将WEB应用放在webapps下，Tomcat会自动映射

**特点**：**方便快捷。无需重启Tomcat。**但会只能跟随Tomcat服务器目录，所以如果Tomcat放在C盘，则会消耗C盘空间。



# 配置虚拟主机

### 简介

在一个tomcat服务器中可以放置多个网站，所谓配置虚拟主机，就是在tomcat服务器中放置一个网站

### 方法

使用服务器配置文件（server.xml）中用户Host元素标签进行配置。

```
<Host name="主机名" appBase="站点目录"/>
```

配置完虚拟主机之后在配置该站点的WEB应用。

```
<Host name="主机名" appBase="站点目录">
<Context path="虚拟目录" docBase="WEB应用实际目录" />
<Host/>
```



# 浏览器访问Web资源的流程

![浏览器访问Web资源的流程图](E:\笔记\JavaWeb\photo\浏览器访问Web资源的流程图.png)

### 主机名作用

1. 通过主机名搜索DNS服务器查找服务器IP
2. 在发送HTTP请求中携带主机名，确定访问的站点



# WEB应用打包

### 命令

```
jar -cvf 包名.war WEB应用目录
```

###jar命令参数

![jar参数](E:\笔记\JavaWeb\photo\jar参数.bmp)

### 打包

![WEB应用打包](E:\笔记\JavaWeb\photo\WEB应用打包.bmp)

将war包直接放在tomcat的默认虚拟主机目录（webapps）下，tomcat会自动识别解压.

# Tomcat体系架构

1. Tomcat启动时会启动一个Service（服务）

2. 这个服务会启动多个Connector(连接器),不同连接器处理不同请求。如处理HTTP，HTTPS（加密请求）。。。

3. 连接器处理请求时会找Tomcat引擎（Engine）

4. Engine会找请求的虚拟主机目录

5. 虚拟主机就找请求的WEB应用

6. WEB应用找到请求对应的WEB资源

   ![img](file:///E:/%E7%AC%94%E8%AE%B0/JavaWeb/photo/Tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.bmp?lastModify=1524404941)

# 配置加密连接器

- 创建数字证书

​       **Java命令**

```
keytool -genkey -alias tomcat -keyalg RSA
```

![创建数字证书](E:\笔记\JavaWeb\photo\创建数字证书.bmp)

- 在server.xml配置加密连接器

```
    <Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
clientAuth="false" sslProtocol="TLS" 
keystoreFile="conf/.keystore"     //数字证书目录
keystorePass="数字证书密钥库密码"  
    />

```

- 通过HTTPS连接器访问WEB应用

![用加密连接器访问WEB应用](E:\笔记\JavaWeb\photo\用加密连接器访问WEB应用.bmp)



# HTTP协议

### 简介

HTTP(Hyper Text Transfer Protocol)超文本传输协议。它是一种请求响应式协议，客户端在与服务端建立连接后，就可以想服务器端发送请求，这种请求被称为**HTTP请求**，服务器端接收到请求后会做出响应，称为**HTTP响应**。

### HTTP1.0和HTTP1.1的区别

一个完整的HTTP请求有四个步骤。1.建立连接→2.发送请求信息→3.响应请求信息→4.关闭连接

HTTP1.0：客户端与服务器建立连接之后，中间只能处理一次请求和发送一次响应。所以客户端每次发送请求信息都要与服务端重新建立连接

HTTP1.1：克服了HTTP1.0的缺陷。在中间客户端可多次发送请求信息，服务器端也可会送多次响应信息。无须重新建立连接。有效的解决了性能问题和交互时间。

### HTTP请求消息

#### 简介

一个完整的请求消息是由**请求行**、**请求头**、**实体内容**三部分组成。每部分都有各自不同的作用。

#### 请求方式

GET（常见）：请求获取请求行的URI**所标识的资源**

POST(常见)   ：向指定资源**提交数据**（如提交表单和上传文件），请求服务器进行处理

HEAD：请求获取有URI**所标识资源的响应头**

PUT:将网页放置到指定URL位置**（上传或移动）**

DELETE:请求服务器**删除**URI所标识的资源

TRACE:请求服务器回送收到的请求信息（主要用于测试或诊断）

CONNECT:保留将来使用

OPTIONS:请求查询服务器的性能，或者查询与资源相关的选项和需求

#### 请求行

HTTP请求行位于请求消息的第一行，它包括三部分。**请求方式**、**资源路径**、**HTTP版本**

如

```
GET /index.html HTTP/1.1
```

#### HTTP请求头

在HTTP请求消息中，请求行之后，便是若干请求消息头。请求消息头主要用于向服务器端传递附加消息。例如，客户端可以接受的数据类型，压缩方式，语言以及发送请求的超链接所属页面的URL地址等。。。

如↓

```
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.9
Cache-Control:max-age=0
Connection:keep-alive
Host:www.baidu.com
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
```

- **Accept**

  用于指出客户端程序（浏览器。。。）能够处理的MIME(Multipurpose Internet Mail Extensions,多用途互联网邮件扩展)类型。例如，如果浏览器和服务器同时支持png类型的图片，则浏览器可以发送包含imgge/png的Accept头字段。服务器的检查到Accept头中包含image/png这种类型的MIME类型，可能在网页中的<img/>标签元素使用png类型文件。

  ```
  Accept:text/html  --表明客户端希望接收HTML文本
  Accept:image/gif  --表明客户端希望接收GIF图像格式资源
  Accept:imgge/*    --表明客户端可以接收所有image格式的子类型图像格式资源
  Accept：*/*       --表明客户端可以接收所有格式的内容
  ```


- Accept-Charset

  用于告知服务器端，客户端所使用的字符集。

  ```
  Accept-Charset:ISO-8859-1[,其他字符集]
  ```

- Accept-Encoding

  指定客户端能够进行解码的数据编码方式，这里的编码方式通常指的是某种压缩方式，注意跟编码集进行区别。

  gzip和compress，这两种格式是最常见的数据编码方式。在传输较大的实体内容之前，对其进行压缩编码，可以节省网络带宽和传输时间。服务器接收到这个请求头，它使用其中指定的一种格式压缩编码方式对原始文档内容进行压缩编码，然后在将其做为响应消息的实体内容发送给客户端，并且在Content-Encoding响应头中指出实体内容所使用的压缩编码格式。浏览器在接受到这样的实体内容之后，需要对其进行反向解压缩。

  ```
  Accept-Encoding:gzip【,compress】
  ```

- Accept-Language

  用于指定客户端期望服务器返回哪个国家语言的文档，它的值可以指定多个国家的语言。

  ```
  Accept-Language:zh-en【,en-us】
  ```

- Host

  用于指定资源所在主机名和端口号，格式与资源的完整URL中主机名和端口号部分相同

  ```
  Host:www.jr.com:8080
  ```

  在HTTP1.1中，客户端发送的每个请求消息中必须包含Host请求头字段，以便WEB服务器能够根据Host头字段中的主机名来区分客户端所访问的虚拟Web站点

- If-Match

  浏览器和代理服务器都可以缓存服务器回送的网页文档。当用户再次访问已缓存的页面时，只有网页内容已被更新，服务器才需要把该页面的内容重新回送到客户端，否则会通知浏览器访问本地缓存的页面，以减少不必要的网络传输流量。当服务器为客户端传送网页文件的内容时，可以传输一些代表实体内容特征的头字段，这些头字段被称为**实体标签**，当客户端再次向服务器请求这个网页文件时，可以使用If-Match头字段附带以前缓存的实体标签内容，这个请求被视为一个条件请求.

  ```
  IF-Match:"repository"  --repository:以前缓存的实体标签内容
  ```

  其中,"repository"是客户端上次访问Web服务器中该页面时,服务器使用ETag实体标签传送的内容

  ```
  ETag:"repository"
  ```

  服务器收到客户端的请求后,会检索If-Match头字段中的实体标签内容,并与服务器端的代表当前网页内容特征的实体标签内容进行比较,如果两者相同,则表示网页内容没有更改,Web服务器不返回网页文档,让客户端仍然使用以前缓存的网页文档.否则,服务器返回新的网页文件和新的实体标签内容头字段.

- If-Modified-Since

  If-Modified-Since请求头的作用和If-Match类似,只不过它的值为GMT格式的时间.If-Modified-Since请求头被视为一个请求条件,只有服务器中的文档的修改时间比If-Modified-Since请求头指定的时间新,服务器才会返回文档内容.否则,服务器将返回一个304状态码来表示客户端缓存的文档是最新的,而不想客户端返回文档内容,这时,浏览器仍使用以前缓存的文档.

- Range和If-Range

  Range头字段用于指定服务器只需返回文档中的部分内容以及内容范围,这对较大文档的断电续传非常有用.如果客户端在一次请求中直接收待服务器返回的部分内容就中断了,可以在第二次请求中,使用Range头字段要求服务器只返回中断位置之后的内容.

  **Range头字段的一下几种使用格式**

  ```
  Range:byte=1000-2000      --请求服务器返回文档中的第1000~2000个字节之间的内容
  Range:byte=1000-          --请求服务器返回文档中的第1000个字节之后的内容
  Range:byte=-1000          --请求服务器返回文档中的最后1000个字节的内容
  ```

  If-Range头字段只能伴随Range头字段一起使用,其设置值可以是实体标签或GMT格式的时间.如果设置值为实体标签,且该标签内容与服务器端代表当前的网页内容特征的实体标签内容相同,则服务器按Range头的要求返回网页中的部分内容,否则,服务器返回当前网页的所有内容,如果设置值为GMT格式的时间,并且自从这个时间以来,服务器上保存的该网页文件没有发生修改,则服务器按Range头的要求返回网页中的部分内容,否则,服务器返回当前网页的所有内容.

- Max-Forward

  指定当前请求可以途经的代理服务器数量,每经过一个代理服务器,此数量就减1.当Max-Forward请求头的值为0时,如果请求没有到达最终的Web服务器,那么最后的代理服务器将终止转发这个请求,由最后的代理服务器来响应客户端的请求.

- Referer

  浏览器向服务器发送的请求,可能是直接在浏览器中输入URL地址发出的,也可能是单击一个网页上的超链接而发出的,对于第一种直接在浏览器地址中输入URL地址的情况,浏览器不会发送Referer请求头,而对于第二种情况,浏览器会使用Referer头字段标识发出请求的超链接所在的页面的URL.

  ```
Referer:httt://www.jr.com/index.html
  ```

  Referer头字段非常有用,常被网站管理员用来追踪网站的访问者是如何导航进入网站的.同时,Referer头字段还可以用于网站的防盗链.

  **什么是盗链?**

  假设一个网站的首页想显示一些图片信息,而在该网站的服务器中并没有这些图片的资源,它通过在HTML文件中使用<img/>元素链接到其他网站的图片资源,将其展示给浏览者,这就是盗链.盗链的网站提高了自己网站的访问量,却加重了被链接网站服务器的负担,损害了其合法的利益.

- User-Agent

  User-Agent(用户代理,简称UA),它用于指定浏览器或者其他客户端程序使用的操作系统以及版本,浏览器渲染引擎,浏览器语言等.一边服务器针对不同类型的浏览器而返回不同的内容.例如,服务器可以通过User-Agent头字段,如果发现客户端是一台无限手持终端(手机),就返回WML文档;如果客户端是一个普通的浏览器,则返回通常的HTML文档

  ```

  ```

### HTTP响应消息

#### 简介

当服务器收到客户端请求后,会回送响应消息给客户端.一个完整的响应消息主要包括**响应状态行**,**响应消息头**,**实体内容**.每个组成部分都代表不同的含义.

#### 响应状态行

HTTP响应状态行位于响应消息的第一行,它包括三个部分,分别是**HTTP版本**,**状态码**,和**状态码的描述**

```
HTTP/1.1 200 OK
```

#### 响应状态码

状态码由三位数字组成,表示请求是否被理解或被满足.HTTP响应状态码的第一个数字定义了响应的类别,后面两位 没有具体分类,第一个数字有5种可能取值.

> 1xx:表示请求已接受,需要继续处理
>
> 2xx:表示请求已成功被服务器端接受,理解并接受.
>
> 3xx:为完成请求,客户端需进一步细化请求
>
> 4xx:客户端的请求有错误
>
> 5xx:服务器端出现错误

**常见状态码**

200:表示服务器成功处理了客户端的请求

302:表示请求的资源临时从不同的URI响应请求,但请求者应继续使用原有位置来进行以后的请求.例如,在请求重定向中,临时URI应该是响应消息中的Location头字段所指的资源

404:表示服务器找不到请求的资源.例如,访问服务器不存在的页面经常返回此状态码

500:表示服务器发生错误,无法处理客户端的请求

#### 响应消息头

在HTTP响应消息中,第一行为响应状态行,紧接着的是若干响应消息头,服务器端通过响应消息头向客户端传递附加信息,包括**服务程序名 **,  **被请求资源需要的认证方式**  , **客户端请求资源的最后修改时间**   ,   **重定向地址等消息.**

```
Accept-Ranges:bytes
Age:340917
Cache-Control:max-age=2592000
Content-Length:874
Content-Type:image/png
Date:Mon, 16 Apr 2018 10:33:06 GMT
ETag:"5acf2349-36a"
Expires:Sat, 12 May 2018 11:51:08 GMT
Last-Modified:Thu, 12 Apr 2018 09:13:45 GMT
```

- Accept-Range

  说明服务器是否接受客户端使用Range请求头字段请求资源.

  如果服务器想告诉客户端不要使用Range头字段,则使用下面的头信息

  ```
  Accept-Range:none
  ```

  如果服务器想告诉客户端可以使用以byte为单位的Range头字段,则使用下面的头信息

  ```
Accept-Range:byte
  ```

- Age

  指出当前网页文档可以在客户端或代理服务器中缓存的有效时间(单位秒)

  ```
  Age:1234567       
  ```

  客户端再次访问已缓存的某个网页文档内容时,先用当前的时间值减去服务器返回该网页时所设置的Date头字段值,如果结果小于Age字段值,客户端直接使用缓存中的网页内容.否则,客户端将向服务器重新发出请求获取最新网页文档.

- Etag

  向客户端传送代表实体内容特征的标记信息,这些标记信息称为实体标签,每个版本的资源的实体标签时不同的,通过实体标签可以判断在不同时间获得的同意资源路径下的实体内容时相同的.例如,在一个文档最后添加一个回车换行,Etag头字段的值就能表示不同.

  ```
  Etag:abc123456
  ```

- Location

  通知客户端获取请求文档的最新地址,其值为一个使用绝对路径的URL地址

  ```
  Location:http://www.baidu.com
  ```

  Location头字段和大多数3xx状态码配合使用,以便通知客户端字段重新连接到最新的地址请求文档.由于当前响应并没有直接返回内容给客户端,所以使用Location头的HTTP消息不应该有实体内容,由此可见,在HTTP消息头中不应该同时出现Location和Content-Type这两个头字段.

- Retry-After头字段可以与503状态码配合使用,告诉客户端在什么时间可以重新发送请求.也可以与任何一个3xx状态码配置使用,告诉客户端处理重定向的最小延时时间.

  Retry-After头字段的值可以是GMT格式的时间也可以时以秒为单位的时间数

  ```
  Retry-After：Mon,18 Nov 2013 19:01:51 GMT
  Retry-After:120          --120秒
  ```

- Server

  告知客户端该服务器软件产品的名称

  ```
  Server:Apache-Coyote/1.1
  ```

- Vary

  用于指定影响了服务器所生成的响应实体内容的那些请求头字段名

  ```
  Vary:Accept-Language
  ```

  上面的响应头字段说明了服务器响应的实体内容受到了客户端发送的Accept-Language请求头的影响，服务器根据Accept-Language请求头的值，返回相应语言种类的网页内容。

  当客户端再次访问已经缓存的资源时，需要检查Vary头字段中指定的请求头字段，检查请求头字段的这次设置与上次的设置是否相同，以此作为是否使用缓存的条件

  例如，上次请求中Accept-Language头字段的值为en-us，而这次的Accept-Language头字段的值为zh-cn，即使客户端使用请求资源路径的本地缓存的其他条件都成立，但客户端也不能使用缓存，需要重新发出访问请求资源.

- Refresh

  告诉浏览器字段刷新页面的时间,它的值可以是以秒为单位的时间数

  ```
  Refresh:3
  ```

  需要注意的是,在Refresh头字段的时间值后面还可以增加一个URL参数,时间值与URL之间用分号(;)分隔,告诉浏览器在指定的时间值后跳转到其他页面

  ```
  Refresh:3;url=http://www.baidu.com
  ```

- Content-Disposition

  如果服务器希望浏览器不是直接处理响应的实体内容,而是让用户选择将响应的实体内容保存到一个文件中,这需要使用Content-Disposition头字段.在Content-Disposition指定了接受程序处理数据内容的方式,有**inline**和**attachment**两者标准方式.

  inline表示直接处理

  attachment则要求用户干预并控制接受程序处理数据的方式.在attachment后面还可以指定filename参数.

  filename参数值是服务器建议浏览器保存实体内容的文件名称.

  ```
Content-Disposition:attachment;filename=jr.zip
  ```

  **注意**

  在设置Content-Disposition之前一定要设置Content-type响应字段头

####通用头字段

在HTTP消息中,有些头字段既适用与请求消息也适用于响应消息,这样的字段被称为通用头字段.

- Cache-Control

  如果Cache-Control用在请求消息中,它用于通知位于客户端和服务器端之间的代理服务器如何使用已缓存的页面.

  如果是Cache-Control用在响应消息中,它用于通知客户端和代理服务器如何缓存页面.

  **Cache-Control取值含义**

  > **public**:文档可以被任何客户端缓存

  ​

  > **private**:文档只能被保存在单个用户的私有缓存中

  ​

  > **no-cache**:如果no-cache后没有指定字段名,则客户机和代理服务器不应该缓存该文件.也可以在no-cache后指定一个或多个其他的头字段名.这样代理服务器可以缓存该页面内容对以后的请求进行响应,但响应消息中不能包含no-cache后指定的头字段.
  >
  > 例如,不想让客户端和代理服务器缓存Cookie信息,可以使用no-cache=Set-Cookie

  ​

  > **no-store**:请求和响应消息都不应被存储在对方的磁盘系统上,存储与缓存是有区别的.缓存是将信息保存在内存或磁盘系统中,而存储专将信息保存在磁盘系统.

  ​

  > **must-revalidate**:对于客户端的每次请求,代理服务器必须向服务器验证缓存的文档是否过时,以保证总是发送最新的文档给客户端.

  ​

  > **proxy-revalidate**:除了只能用于共享缓存外,其作用与must-revalidate相同,因为可能有多台代理服务器,一级一级向上请求知道最终服务器.故为了保证客户端向服务器端请求经过的每级代理服务器得到服务器的文档是最新的

  ​

  > **max-age=n:**在n秒后认为文档过时,它可以替代Expires头的作用,如果响应头同时给出Cache-Control头的max-age设置值和Expires头,则以Cache-Control头的max-age为准

  ​

  > **s-max-age=n:**在代理服务器中缓存的文档(通常称为共享缓存)在n后过时

- Connection

  指定处理完本次请求/响应后,客户端和服务器端是否还要继续保持连接.

  ```
  Connection:Keep-Alive        --继续连接
  Connection:close             --关闭连接
  ```

  对于HTTP1.1版本来说,默认采用持久连接,也就是说,默认情况下Connection头字段的值是Keep-Alive.

- Date

  表示HTTP消息产生的当前时间,它的值为GMT格式

  ```
  Date:Mon,18 Nov 2013 19:01:51 GMT
  ```

- Transger-Encoding

  对于HTTP1.1来说,由于服务器端和客户端保持持久连接,服务器端必须在响应消息中通过Content-Length头字段通知客户端响应数据的长度,客户端才能知道数据合适传输完毕.

  然而,在服务器端,有些数据是动态生成的,服务器必须等所有内容生成后才能准确地计算出响应数据的长度,也就是说只有当前所有数据生成完毕后服务端才能响应客户端的请求.

  这样势必会影响效率.为了解决这个问题,Transger-Encoding头字段被引入,这个头字段指定响应消息的实体内容采用哪种传输编码方式,目前标准设置值只有**chunked**

  ```
  Transger-Encoding:chunked
  ```

  **chunked传输编码方式**

  当响应消息中设置了Transger-Encoding头字段后,会把响应消息的整个实体内容分成一连串后在进行传输.

  每个分段的开始都是一个十六进制的数据,用来表示整个分段的大小.最后一个分段必须是0,表示整个chunked编码数据的结束.

  如下一个完整的响应消息

  ```
  HTTP/1.1 200 OK
  Content-Type:text/html
  Transfer-Encoding:chunked

  7f
  <html>
  <head>
  <title>Trailer Example</title>
  </head>

  2c
  <body>
  </body>
  </html>

  0
  ```

上面的响应消息中的,7f和2c代表两个分段内容的大小标识信息

在有了Transfer-Encoding头字段之后不必用Content-Length头字段来指定实体内容的大小

- Content-Range

  指定服务器返回实体内容的位置信息.只有客户端使用了Range请求头要求服务器返回实体的部分内容是,服务器的响应头中才会包含Content-Range头

  ```
  Content-Range:bytes 21010-47021/47022
  ```

  在Content-Range头字段中,bytes说明后面的数据以byte单位,21010~47021说明返回的内容从第21010个字节开始到47021个字节结束,/47022说明整体实体内容的大小为47022个字节.

- Content-Type

  指出实体内容的MIME类型.由于通过HTTP传输的数据也有各种类型,因此,HTTP也采用了MIME来标识不同的数据类型.客户端通过检查响应头字段的Content-Type中的MIME类型,就能知道接收到的实体内容代表哪种格式的数据类型,从而进行正确的处理.

  Content-Type头字段中的MIME类型后面还可以指定响应内容所使用的字符码表,两者之间用分号(;)和空格隔开.

  如

  ```
  Content-Type:text/html; charset=UTF-8
  ```

  如果头字段中没有指定字符码表,默认使用ISO-8859-1

- Content-Encoding

  指定实体内容的压缩编码方式.服务器对实体内容的压缩不会影响实体内容的MIME类型,当被压缩的实体内容在客户端被解压后,其MIME类型与Content-Type头字段指定的类型一致

- Expires

  指定当前文档的过期时间,浏览器在这个时间以后不能在继续使用本地缓存,而需要向服务器发出新的访问请求.

  Expires头字段的设置值应该为GMT格式时间.

  ```
  Expires:Mon,18 Nov 2013 19:01:51 GMT
  ```

  由于浏览器的兼容问题,在设置网页不缓存时,一般将Pragma,Cache-Control,Expires三个字段一起使用;

- Last-Modified

  指定文档最后的更改时间,设置值为GMT格式的时间.当客户端接收到Last-Modified头字段后,它将在以后的请求消息中发送一个If-Modified-Since请求消息头来指出缓存文档的最后更新时间,也就时Last-Modified响应头中的时间,就是下次请求消息中If-Modified-Since请求字段头指定的时间.

  ​

# Servlet

### 简介

随着Web应用业务需求的增多,动态Web资源的开发变得越来越重要.目前,很多公司都提供了开发动态Web资源的相关技术,其中比较常见的有ASP,PHP,JSP和Servlet等.基于Java的动态Web资源开发,Sun公司提供了Servlet和JSP两种技术

### 创建Servlet对象

#### 实现 Servlet接口

```
public class MyGenericServlet implements Servlet {
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}

```

- void init(ServletConfig config)

负责Servlet初始化工作.容器在创建号Servlet对象后,就会调用此方法.该方法接受一个ServletConfig类型的参数,Servlet容器通过这个参数向Servlet传递初始化配置信息

- ServletConfig getServletConfig()

返回容器调用init(ServletConfig config)方法时传递给Servlet的ServletConfig对象,系统自行

- String getServletInfo()

返回一个字符串,其中包含关于Servlet的信息.例如,作者,版本,和版权信息等

- void service(ServletRequest request,ServletResponse response)

负责响应用户请求,当容器接受到客户端访问Servlet对象的请求时,就会调用此方法.容器会构造一个表示客户端请求信息的ServletRequest对象和一个响应客户端的ServletResponse对象作为参数传递给service()方法.在service()方法中,可以通过ServletRequest对象得到客户端的相关信息和请求信息,在对请求进行处理后,调用ServletResponse对象的方法设置响应信息.

- void destroy()

负责释放Servlet对象占用的资源.当Servlet对象被销毁时,容器会调用此方法.

#### 继承Servlet对象实现Servlet方法

由于直接实现Servlet接口来编写Servlet很不方便,需要实现很多方法.

- 因此可以通过继承Servlet接口的实现类javax.servlet.GenericServlet来实现

```
public class MyGenericServlet extends GenericServlet{
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

    }
}

```

MyGennericServlet继承GenericServlet后,只实现了service()方法.这是因为GenericServlet类除了Servlet接口的service()方法外,其他方法都已经实现.由此可见.继承GenericServlet比实现Servlet接口更加简便.

- 通过继承Servlet接口的实现类javax.servlet.http.HttpServlet来实现

它是GenericServlet的子类,专门用于创建应用与HTTP大的Servlet.

```
@WebServlet(name = "Servlet")
public class MyHttpServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }
}

```

**HttpServlet主要有两大功能**

1. 根据用户的请求方式的不同,定义相应的doXXX()方法处理用户请求.如,与GET请求方式对应的doGet()方法,

   与POST方式对应的doPost()方法.

2. 通过service方法将HTTP请求和响应分别转为HttpServletRequest和HttpServletResponse类型对象

需要注意的是,由于HttpServlet类在重写的service()方法中,为每一种HTTP请求方式都定义了对应的doxxx()方法,因此,当定义的类继承HttpServlet后,只需根据请求方法,重写对应的doxxx()即可,不需要重写service()方法.

### Servlet的映射

```
<servlet>
    <servlet-name>Myhttpservlet</servlet-name>
    <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>Myhttpservlet</servlet-name>
    <url-pattern>/myhttpservlet</url-pattern>
</servlet-mapping>
```

上面的配置信息中,元素<servlet>用于注册Servlet,它的两个元素<servlet-name>和<servlet-class>分别指定Servlet名称及其完整类名

元素<servlet-mapping>用于映射Servet对外访问的虚拟路径,它的子元素<servlet-name>必须和<servlet>中的<servlet-name>相同,元素<url-pattern>则是用于指定访问该Servlet的虚拟路径,该路径以"/"开头,代表当前的Web应用的根目录

#### Servlet的多重映射

Servlet的多重映射指的是同一个Servlet可以被映射成多个虚拟路径.也就是说,客户端可以通过多个路径对同一个Servlet进行访问.

- 配置多个<servlet-mapping>元素

  ```
      <servlet>
          <servlet-name>Myhttpservlet</servlet-name>
          <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
          <load-on-startup>1</load-on-startup>
      </servlet>
      <servlet-mapping>
          <servlet-name>Myhttpservlet</servlet-name>
          <url-pattern>/myhttpservlet01</url-pattern>
      </servlet-mapping>
      <servlet-mapping>
          <servlet-name>Myhttpservlet</servlet-name>
          <url-pattern>/myhttpservlet02</url-pattern>
      </servlet-mapping>
  ```

- 在<servlet-mapping>元素中配置多个<url-pattern>子元素

  ```
      <servlet>
          <servlet-name>Myhttpservlet</servlet-name>
          <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
          <load-on-startup>1</load-on-startup>
      </servlet>
      <servlet-mapping>
          <servlet-name>Myhttpservlet</servlet-name>
          <url-pattern>/myhttpservlet01</url-pattern>
          <url-pattern>/myhttpservlet02</url-pattern>
      </servlet-mapping>
  ```

#### Servlet映射路径中使用通配符

有时候,我们希望某个目录下的所有路径都访问同一个Servlet,这时,可以在Servlet映射的路径中使用通配符"*"

- 格式为"\*.扩展名",例如"\*.do"匹配以".do"结尾的所有URL地址
- 格式为"/\**" ; 例如"abc/*\*"匹配以abc开始的所有URL地址

**注意**

两种格式不能混合使用

#### 自动加载Servlet程序

有时候,我们希望某些Servlet程序可以在Tomcat启动是随机启动.例如,当启动一个Web项目时,首先需要对数据库信息进行初始化.

那么可以在Web.xml文件中映射Servlet时,添加<servlet>的一个子元素<load-on-startup>

在<load-on-startup>元素中,其值必须是一个整数.如果这个值是一个负数,或者没有设定这个元素,Servlet容器将在客户端首次请求这个Servlet时加载它;如果这个值是正整数或0,Servlet容器将在Web应用启动时加载并初始化Servlet.

值越小,它对应的Servlet就越被优先加载

```
<servlet>
    <servlet-name>Myhttpservlet</servlet-name>
    <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>Myhttpservlet</servlet-name>
    <url-pattern>/myhttpservlet</url-pattern>
</servlet-mapping>
```

#### 

### Servlet的生命周期



![Servlet的声明周期](E:\笔记\JavaWeb\photo\Servlet的声明周期.jpg)



根据功能的不同,大致可以将Servlet的生命周期分为三个阶段,分别是**初始化阶段**,**运行阶段**,和**销毁阶段**

- 初始化阶段

  当客户端向Servlet容器发出HTTP请求要求访问Servlet时,Servlet容器首先会解析请求,检查内存中是否已经有了该Servlet对象,如果有直接使用该Servlet对象,如果就创建Servlet实例对象,然后通过调用init()方法实现Servlet的初始化工作,需要注意的是,在Servlet的整个生命周期内,它的init()方法只被调用一次

- 运行阶段

  这是Servlet声明周期中最重要的阶段,在这个阶段,Servlet容器会为这个请求创建代表HTTP请求的ServletRequest对象和代表HTTP响应的ServletResponse对象,然后将它们作为参数传递给Servlet的service()方法.service()方法从ServletRequest对象中获取客户请求信息和处理该请求,通过ServletResponse对象生成响应结果.在Servlet的整个生命周期内,对于Servlet的每次访问请求,Servlet容器都会调用一次Servlet的service()方法,并且创建新的ServletRequest和ServletResponse对象,也就是说,service()方法在Servlet的整个生命周期终会被调用多次.

- 销毁阶段

  当服务器关闭或Web应用被移除容器时,Servlet随着Web应用的销毁而销毁.在销毁Servlet之前,Servlet容器会调用Servlet的destory()方法,以便让Servlet对象释放它所占的资源.在Servlet的整个生命周期中,destroy()方法也只被调用一次.

### 注意

1. 继承HttpServlet后，需要重写对应的doGet（）或doPost（），而不要调用父类的doGet（）和doPost（）方法



# ServletConfig

### 简介

在Servlet运行期间,经常需要一些辅助信息,例如,文件使用的编码,使用Servlet程序的公司等,这些信息可以在web.xml文件使用一个或多个<init-param>元素进行配置.当Tomcat初始化一个Servlet时,会将该Servlet的配置信息封装到一个ServletConfig对象中,通过调用init(ServletConfig config)方法将ServletConfig对象传递给Servlet.

```
   <servlet>
        <servlet-name>Myhttpservlet</servlet-name>
        <servlet-class>com.jr.exmaple.MyHttpServlet</servlet-class>
        <init-param>
            <param-name>初始化参数名</param-name>
            <param-value>初始化参数值</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>Myhttpservlet</servlet-name>
        <url-pattern>/myhttpservlet01</url-pattern>
    </servlet-mapping>
```

### ServletConfig常用方法

- String getInitParameter(String name)

  根据初始化参数名返回对应的初始化参数值

- Enumeration getInitParameterNames()

  返回一个Enumeration对象,包括所有的初始化参数名

- ServletContext getServletContext

  返回代表Web应用的ServletContext对象

- String getServletName()

  返回Servlet的名字,即web.xml中<servlet-name>元素的值

# ServletContext

### 简介

当Servlet容器启动时,会为每个Web应用创建一个唯一的ServletContext对象代表当前Web应用,该对象不仅封装了当前Web应用的所有信息,而且实现了多个Servlet之间的数据共享.

### 配置Web应用的初始化参数

```
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0"
         metadata-complete="true">
<context-param>
    <param-name>参数名</param-name>
    <param-value>参数值</param-value>
</context-param>
</web-app>
```

### 获取Web应用的初始化参数

- Enumeration getInitParameterNames()

  得到包含所有初始化参数名的Enumeration对象

- String getInitParameter(String name) 

  根据参数名获取参数值

### 多个Servlet对象共享数据

由于一个Web'应用中所有Servlet共享同一个ServletContext对象,因此ServletContext对象的域属性可以被该Web应用中的所有Servlet访问.在ServletContext接口中定义了分别用于增加,删除,设置ServletContext域属性的4个方法.

- Enumeration getAttributeNames()

  返回一个Enumeration对象,该对象包含所有存放在ServletContext中的所有域属性名

- Object getAttbute(String name)

  根据参数指定的属性名返回一个与之匹配的域属性值

- void removeAttribute(String name)

  根据参数指定的域属性名,从ServletContext中删除匹配的域属性

- void setAttribute(String name,Object obj)

  设置ServletContext的域属性,其中name时域属性名,obj时域属性值

#### 注意

ServetContext的数据是全局,共享的.

也就是说一个客户端对数据的修改,对另外其他客户端而言是已知的

所以一般不在ServletContext进行数据的传递

# 请求和响应

### 简介

Servlet最主要的作用就是处理客户端请求,并向客户端做出响应.为此,针对Servlet的每次请求,Web服务器在调用service()之前,都会创建两个对象,分别时HttpServletRequest和HttpServletResponse.

其中,HttpServletRequest用于封装HTTP请求消息,简称request对象.

HttpServletResponse用于封装HTTP响应消息,简称response对象.

![客户端访问Servlet流程图](E:\笔记\JavaWeb\photo\客户端访问Servlet流程图.jpg)



### HttpServletResponse对象

在Servlet API中,定义了一个HttpServletResponse对象,它继承自ServletResponse,专门用来封装HTTP响应消息.由于HTTP响应消息分为**状态行**,**响应消息头**,**消息体**三部分,因此,在HttpServletResponse接口中定义了向客户端发送响应状态码和响应消息头,响应消息体的方法.

#### 发送状态码的相关方法

- setStatus(int status)

  该方法用于设置HTTP响应消息的状态码,并生成响应状态行.由于响应状态行中的状态描述信息直接与状态码相关,而HTTP版本有服务器确定,因此,只要通过setStatus(int status)方法设置了状态码,即可实现状态行的发送.

  正常情况下,Web服务器会默认产生一个200的状态行.

- setError(int sc)

  发送表示错误信息的状态行,例如,404状态码表示找不到客户端请求的资源.

- setError(int sc,String message)

  附加一条用于提示说明的文本信息,该文本信息将出现在发送给客户端的正文内容中

#### 发送响应消息头的相关方法

- void addHeader(String name,String value)

  void setHeader(String name,String value)

  这两个方法都是用来设置HTTP的响应头字段,其中,参数name用于指定响应头字段的名称,参数value用于指定响应头字段的值.不同的是,addHeader()方法可以增加同名的响应头字段,而setHeader()会覆盖同名的前头字段

- void addIntHeader(String name,int value)

  void setIntHeader(String name,int value)

  这两个方法专门用于设置包含整数的响应头.避免了使用addHeader()和serHeader()方法时,需要将int类型的设置值转换为String类型的麻烦

- void setContentLength(int length)

  该方法用于设置相应消息的实体内容的大小,单位为字节.对于HTTP来说,这个方法就是设置了Content-Length响应头字段的值

- void setContentType(String type)

  该方法用于设置Servlet输出内容的MIME类型,对于HTTP来说,就是设置了Content-Type响应头字段的值.

- void setLocale(Locale loc)

  该方法用于设置响应消息的本地化信息.对于HTTP消息来说,就是设置Content-Language响应头字段和Content-Type头字段的字符集编码部分.

- void setCharacterEncoding(String charset)

  该方法用于设置输出内容使用的字符编码,对HTTP来说,就是设置Content-Type头字段中的字符集编码部分.

  如果没有设置Content-Type头字段,setCharacterEncoding方法设置的字符集编码不会出现在HTTP消息的响应头中.

  setCharcterEncoding()方法比setContentType()和setLocale()方法的优先级高.它设置的字符集结果会覆盖setContentType()和setLocale()方法所设置的字符集表

#### 发送响应消息体的相关方法

- getOutputStream()

  该方法所获取的字节输出流对象为ServletOutputStream类型.由于ServletOutputStream时OutputStream的子类,它可以直接输出字节数组的二进制数据.

- getWriter()

  该方法所获取的字符输出流对象为PrintWriter类型.PrintWriter类型的对象可以直接输出字符文本内容

##### 注意

虽然respone对象的getOutputStream()和getWriter()方法都可以发送响应消息体,但是,它们之间相互排斥,不可以同时使用,否则会发送IllegeStateException异常

因为getWriter()方法内部调用了getOutputStream().

#### HttpServletResponse应用

##### 中文输出乱码问题

由于计算机中的数据都是以二进制形式存储的,因此,当传输文本时,就会发生字符和字节之间的转换.字符与字节之间的转换时通过查码表完成的,将字符转换成字节的过程称之为**编码**,将字节转换成字符的过程称之为**解码**,如果编码和解码使用的码表不一致就会导致乱码问题.

由于response对象的字符输出流在编码时,默认采用的是ISO 8859-1的字符码表,该码表不兼容中文.

而浏览器默认采用GB2312码表进行解码,所以必定会造成乱码.

**解决方法**

- 分两部走

1. 指定response存储引擎编码码表

```
response.setChatacterEncoding("utf-8");
```

2. 通知浏览器使用码表解码

```
response.setHeader("Content-Type","text/html;charset=utf-8");
```

- 一步解决

```
response.setContentType("text/html;charset=utf-8");
```

##### 页面定时刷新并跳转

在HTTP中,定义了一个Refresh头字段,它可以通知浏览器在指定时间内自动刷新并跳转到其他页面.

```
response.setHeader("Refresh","2")                    --两秒后进行刷新
response.setHeader("Refresh","2;URL=跳转地址")        --两秒后进行跳转到指定地址
```

##### 禁止浏览器缓存页面

```
response.setDateHeader("Expires",0);
response.setHeader("Cache-Control","no-cache");
response.setHeader("Pragma","no-cache");
```

由于不同浏览器对他们的支持不同,一般在响应消息中将这个三个头字段都设置

##### 请求重定向

为了实现请求重定向,在HttpServletResponse接口中,定义了一个sendRedirect()方法

该方法用于生成302响应码和Location响应头字段,从而通知客户端重新访问Location响应头中指定的URL.

```
response.sendRedirect("/Web应用指定资源");   --"/"表示Web应用根目录
```

### HttpServletRequest对象

 #### 获取请求行信息的相关方法

- String getMethod（）

  获取HTTP请求信息中的请求方式（GET.POST...）

- String getRequestURI（）

  获取请求行中的资源名称部分，即位于URI的主机名和端口号之后，参数部分之前的部分

- String getQueryString（）

  获取请求行中的参数部分，即“?”之后的所有内容

- String getProtocol（）

  获取请求行中的协议名和版本，例如，HTTP1.0或HTTP1.1

- String getContextPath（）

  获取请求URL中属于Web应用程序的路径，这个路径以“/“开头，表示相对域整个Weeb站点的根目录，路径结尾不含”/“。

- String getPathInfo（）

  获取请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以”/“开头。如果没有额外路劲信息部分，返回null

- String getPathTranslated（）

  获取URL中额外路径信息所对应的资源的真实路径。

#### 获取请求消息头的相关方法

- String getHeader（String name）

  获取一个指定头字段的值，如果请求消息中不存在指定的头字段，返回null。如果消息头中包含多个指定的头字段。返回第一个头字段的值。

- Enumeration getHeaders（String name）

  该方法返回一个Enumeration集合对象，该集合对象由请求消息头中出现的某个指定名称的所有头字段值组成

- Enumeration getHeaderNames()

  获取一个包含所有请求头字段的Enumeration对象

- int getIniHeader（String name）

  获取指定名称的头字段值，并将其值转换成int类型。

- long getDateHeader（String name）

  获取指定名称的头字段值，并将其值按GMT时间格式转换成一个代表日期/时间的长整数

- String getContentType（）
  获取Content-Type头字段的值

- int getContentLenth（）

  获取Content-Lenght头字段的值

- String getCharacterEncoding（）

  获取请求消息的实体部分的字符集编码，通常是从Content-Type头字段中提取。

####获取请求消息体的相关方法

- ServletInputStream getInputStream（）

  获取表示实体内容的ServletInputStream对象，如果实体内容为非文本，那么只能通过getInputStream（）方法获取请求消息体

- BufferedReader getReader（）

  获取实体内容的BufferedReader对象，该对象会将实体内容中的字节数据按照请求消息中指定的字符集编码转换成文本字符串。

  也可使用setCharacterEncoding（）方法指定BUfferedReader对象所使用的字符编码。

  如果请求消息没有指定字符集编码，而BufferedReader又没指定字符集编码，那么将默认采用ISO-8859-1

#### HttpServletRequest应用

##### 获取请求参数

- String getParameter（String name）

  获取指定名称的参数值

  如果请求消息中没有存在指定名称的参数，返回null

  如果存在指定名称的参数，但没有设置值，返回”“

  如果存在多个指定名称的参数，返回第一个参数值

- String 【】 getParameterValues（String name）

  获取同一参数名对应的所有参数值

- Enumeration getParameterNames（）

  返回请求消息中的所有参数名的Enumeration对象

- Map getParameterMap（）

  将请求消息中的参数名和参数值封装到一个Map集合

##### 请求参数中文乱码问题

浏览器在传递请求参数时，默认采用的编码方式时GBK，但在解码时采用的是默认的ISO-8869-1，因此出现了参数信息乱码问题

**解决方法**

```
request.setCharacterEncoding("utf-8");  --设置request对象的解码方式
```

**但仅对POST方式有效**

因为setCharacterEncoding（）方法仅对实体内容数据设置有效

而GET方式请求中的参数是附加到请求行内，因此方法对GET方式无效

**GET解决方法**

- 使用错误码表再次编码后在使用正确码表解码

  ```
  String name=request.getParameter("name");//乱码字符串
  name=new String(name.getBytes("错误码表(ISO-8869-1)"),"正确码表(UTF-8)")
  ```

##### 获取网络连接信息

- String getRemoteAddr（）

  获取请求客户端的IP地址

- String getRemoteHost（）

  获取请求客户端的完整主机名

- int getRemotePort（）

  获取请求客户端网络连接的端口号

- 。。。

##### 通过Request对象传递数据

- setAttribute(String name,Object obj)

  将一个对象与一个名称关联后存储进ServletRequest对象

  如果已存在就覆盖原有值

- getAttribute（String name）

  从ServletRequest对象中获取指定名称的属性对象

- removeAttribute（String name）

  从ServletRequest对象中删除指定名称的属性对象

- getAttributeNames（）

  返回一个包含ServletRequest对象中所有属性名的Enumeration对象

######注意

只属于同一次请求中的数据才可以通过ServletRequest对象传递数据

##### RequestDispatcher对象的应用

当一个Web资源收到客户端的请求后，如果希望服务器通知及另外一个资源去处理请求，除了使用sendRedirect（）方法让**客户端去实现请求重定向外**，还可以通过RequestDispatcher接口的实例对象来让**服务器端实现请求转发**

###### 步骤

1. 获取RequestDispatcher对象

- RequestDispatcher getRequestDispatcher（String path）

  返回封装了某个路径所指资源的RequestDispatcher对象。

  其中，参数path必须以"/"开头，用于表示当前Web应用的根目录

2. 通知其他Web资源处理当前Servlet请求

- forward（ServletRequest request，ServletResponse response）

  将请求从一个Servlet传递给另外一个Web资源。最后由它发送响应消息

- include（ServletRequest request，ServletResponse response）

  将其他的资源作为当前响应内容包含进来

  ​

# 会话及其会话技术

### 简介

当用户通过浏览器访问Web应用时，通常情况下，服务器需要对用户的状态进行跟踪。

例如，用户在网站结算商品时，Web服务器必须根据请求用户的身份，找到该用户所购买的商品。

在Web开发中，服务器跟着用户信息的技术称为会话技术。

客户端与Web服务器之间连续发生的一系列请求和响应过程就是一个会话.

例如,一个用户在某网站上整个购物的过程就是一个会话.

### 会话技术保存数据与其他两种的区别

> HttpServletRequest

该对象只能保存本次请求所传递的数据.

> ServletContext

在ServletContext对象保存的数据是共享的,也就是说,某一个客户端对其修改的值,相对其他客户端而言是可见的.

> 会话

为单独的客户端进行数据保存,每个客户端之间的数据彼此分隔

### Cookie

#### 简介

Cookie是一种会话技术,它用于将会话过程中的数据**保存到用户的浏览器本地中**,从而使浏览器和服务器可以更好地进行数据交互.

服务器向客户端发送Cookie时,会在HTTP响应头字段中增加Set-Cookie响应头字段

```
Set-Cookie:Cookie名称=Cookie值;Path=/;Domian="www.jr.com";
```

- Path:表示Cookie的属性

当用于第一次访问服务器时,服务器会在响应消息中增加Set-Cookie头字段,将用户信息以Cookie的形式发送给浏览器.一旦用户浏览器接受了服务器发送的Cookie信息,就会将它保存在浏览器的缓存区中,这样,当浏览器后续访问该服务器时,就会在请求消息中将用户信息以Cookie的形式发送给Web服务器,从而服务器端分辨出当前请求是由哪个用户发出的.

#### Cookie API

**构造方法**

- public Cookie(String name,String value)

>  name:指定Cookie的名称

>  value:指定Cookie的值

**常用方法**

- String getName()

  返回Cookie的名称

- void setValue(String newValue)

  设置Cookie值

- String getValue()

  获取Cookie值

- void setMaxAge(int expiry)

  设置Cookie在浏览器上保持的有效秒数

- int getMaxAge()

  获取Cookie在浏览器上保持的有效秒数

  默认情况下,Cookie对象的Max-Age属性的值时**-1**,即浏览器关闭时,删除这个Cookie对象

  属性值为**0**,即不保存这个Cookie

- void setPath(String uri)

  设置该Cookie项的有效目录路径

  浏览器在访问该有效目录路径时会回送Cookie信息

  如果创建的某个Cookie对象没有设置Path属性,那么该Cookie只对当前访问路径所属的目录及其子目录有效.

  如果想让某个Cookie对站点的所有目录下的访问都有效,应调用Cookie对象的setPath()方法将其Path属性设为"/"

  "/"代表当前Web应用所在目录

- String getPath()

  返回该Cookie项的有效目录路径

- void setDomain(String pattern)

  设置该Cookie项的有效域

  Domain属性的值为当前主机名,浏览器在访问当前主机下的资源时,都会将Cookie信息回送给服务器.

- String getDomain()

  获取该Cookie项的有效域

- void setVersion(int v)

  设置该Cookie采用的协议版本

- int getVersion()

  获取该Cookie采用的协议版本

- void setComment(String purpose)

  设置该Cookie的注解部分

- String getComment()

  获取该Cookie的注解部分

  **使用**

```
Cookie cookie=new Cookie("Cookie名","Cookie值")
response.addCookie(cookie);    //添加到响应头字段
```

​       **响应消息头字段**

```
Set-Cookie:Cookie名=Cookie值; Path=/; 
```

#### 注意

一个站点浏览器只允许存在20个Cookie

### Session

#### 简介

Cookie技术可以将用户的信息保存在各自的浏览器中,并且可以在多次请求下实现数据的共享.

但是,如果传递的信息比较多,使用Cookie技术显然会增大服务器端程序处理的难度.

这时,可以使用Session实现.

**Session是一种将会话数据保存到服务器端的技术**

例如

当我们去医院就诊时,医院都会给就诊病人发放就医卡,卡上只有卡号,而没有其他信息.但是病人每次去该医院就诊时,只要出示就医卡,医务人员便可以根据卡号查询到病人的就诊信息.

Session技术就好比医院发放病人的就医卡和医院为每个病人保留病例档案的过程.

当浏览器访问Web服务器时,Servlet容器就会创建一个Session对象和ID属性,

其中Session对象相当于病例档案,ID相当于就医卡号

后续客户端访问服务器时,只要将标识号传递给服务器,服务器就能判断出该请求是哪个客户端发送的,从而选择与之对应的Session对象为其服务.

**由于客户端需要接受,记录和回送Session对象的ID,因此,通常情况下,Session是借助Cookie技术来传递ID属性的**

#### 利用URL重写实现Session跟踪

前面提到,服务器在传递Session对象的ID属性时,是以Cooklie的形式传递给浏览器的.

但是,如果浏览器的Cookie功能被禁止,那么服务器端是无法通过Session保存用户会话信息的.

考虑到浏览器可能不支持Cookie的情况,Servlet规范种引入了URL重写机制来保存用户的会话信息

所谓URL重写,指的是将Session的会话标识号以参数的形式附加在超链接的URL地址后面.

对于Tomcat服务器来说,就是将JSessionID关键字作为参数名,会话标识号作为参数值附加到URL地址后面

```
String url="资源连接"
HttpSession s=resquest.getSession();
String newURL=response.encodeRedirectURL(url);
resp.sendRedirect(newURL)
```

- 重写前的url

  `/myhttpservlet01?id=jr`

- 重写后的url

  `/myhttpservlet01;jsessionid=2893056D4E449F802FF8461EFF98230C?id=jr`

看出对链接进行URL重写后,URL地址后面跟上了Session的标识号

**注意**

1. 重写URL时,前面要通过getSession()方法获取Session对象

2. 如果下次浏览器把Cookie带过去服务器，那么服务器识别到客户端支持Cookie的话，就不会对URL进行重写

3. 无论浏览器是否支持Cookie,当用于第一次访问程序时,由于服务器不知道用户的浏览器是否支持Cookie,在第一次的响应的页面中都会对URL地址进行重写,如果用户浏览器支持Cookie,那么在后续访问中都会使用Cookie的请求头字段将Session的标识号传递给服务器.

   由此,服务器判断出该浏览器支持Cookie,以后不在对URL进行重写.

   如果浏览器的头信息不包含Cookie请求头字段,那么在后续的每个响应中都需要对URL进行重写.



#### HttpSession  API

**获取Session对象**

- public HttpSession getSession(boolean create)
- public HttpSession getSession()

两种都是返回当前请求相关的HttpSession对象.

不同的是,第一种方法根据传递的参数来判断是否创建新的HttpSession对象.

如果参数为true,则在相关的HttpSession对象不存在时创建新的HttpSession对象,否则不创建,而返回null

第二张情况相当于第一种情况的参数为true

**常用方法**

- String getId()

  返回与当前HttpSession对象关联的会话标识号

- long getCreationTime()

  返回Session创建时间.

- long getLastAccessedTime()

  返回客户端最后一次发送与Session相关请求的时间

- void setMaxInactiveInterval(int interval)

  设置当前HttpSession对象可空闲的以秒为单位的最长时间

- boolean isNew()

  判断当前HttpSession对象是否时最新创建的

- void invalidate()

  强制使Session对象无效,内部存储的数据随机被清空

- ServletContext getServletContext()

  返回当前HttpSession对象所属于的Web应用程序对象

- void setAttribute(String name,Object value)

  将一个对象与一个名称关联后存储到当前HttpSession对象中

- String getAttribute(String name)

  从当前HttpSession对象中返回指定名称的属性对象

- void removeAttribute(String name)

  从当前HttpSession对象种删除指定名称的属性

  ​

#### Session超时管理

当客户端第一次访问某个能开启会话功能的资源时,Web服务器就会创建一个与该客户端对应的HttpSession对象.在HTTP种,Web服务器无法判断当前浏览器客户端是否还会继续访问,也无法检测浏览器客户端是否关闭,所以,即使客户端已经离开或关闭浏览器,Web服务器都还会保存与之对应的HttpSession对象.随着时间的推移,这些不在使用的HttpSession对象会在Web服务器种积累的越来越多,从而使Web服务器的内存耗尽.

为了解决上面的问题,Web服务器采用了**超时限制**的办法来判断客户端是否还在继续访问.

在一定时间内,如果某客户端一直没有请求访问,那么,Web服务器就会认为该客户端已经结束了请求,并将对应的HttpSession对象变成垃圾,等待垃圾收集器将其从内存中彻底删除.

##### 配置超时时间

在<tomcat安装目录>\conf\web.xml文件中,找到↓配置

```
    <session-config>
        <session-timeout>30</session-timeout>
    </session-config>
```

设置的时间值是以分钟为单位,即Tomcat服务器的默认会话超时间隔为30分钟

如果设置为0或一个负数,则表示会话永不超时.

在Web.xml文件对站点内的所有Web'应用都起作用

要想单独设置某个Web应用程序的会话超时间隔,则需要在自己的应用的web.xml文件进行设置

要想Session失效,除了可以等待会话时间超时外,还可以通过invalidate()方法强制使会话失效

# JSP技术

### 简介

在动态页面开发中,经常需要动态生成HTML内容,例如,一篇新闻报道的浏览次数需要动态生成.

这时,如果使用Servlet来实现HTML页面数据得改变,需要调用大量的输出语句,从而使静态内容和动态内容混合在一起,导致程序非常臃肿.

为了克服Servlet的这些缺点.Sun公司推出了JSP

JSP全名是Java Server Page,它是建立在Servlet规范之上的动态网页开发技术

在JSP文件中,HTML代码与Java代码共同存在,其中HTML代码用来实现网页中的静态内容显示,java代码用来实现网页的动态内容的显示

为了与普通的HTML有所区别,JSP文件的扩展名为.jsp

###JSP运行原理

查看到Tomcat服务器中的web.xml文件可知道

```
    <servlet>
        <servlet-name>jsp</servlet-name>
        <servlet-class>org.apache.jasper.servlet.JspServlet</servlet-class>
        <init-param>
            <param-name>fork</param-name>
            <param-value>false</param-value>
        </init-param>
        <init-param>
            <param-name>xpoweredBy</param-name>
            <param-value>false</param-value>
        </init-param>
        <load-on-startup>3</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>jsp</servlet-name>
        <url-pattern>*.jsp</url-pattern>
        <url-pattern>*.jspx</url-pattern>
    </servlet-mapping>

```

从上面的配置信息可以看出,以.jsp为扩展名的URL访问请求都是由org.apache.jasper.servlet.JspServlet处理

所以,Tomcat中的JSP引擎就是一个Servlet程序,该Servlet程序实现了所有JSP页面的解析.

需要注意的是,JSP文件也可以想Servlet程序一样,在web.xml文件中进行注册和映射虚拟路径.注册JSP页面的方式和Servlet类似

**只需要将<servlet-class>元素修改为<jsp-file>元素即可**

```
    <servlet>
        <servlet-name>jsp_servlet</servlet-name>
        <jsp-file>/index.jsp</jsp-file>             --"/"表示Web应用的根目录
    </servlet>
    <servlet-mapping>
        <servlet-name>jsp_servlet</servlet-name>
        <url-pattern>/jsp_servlet</url-pattern>
    </servlet-mapping>
```

1. **翻译编码**

当用户第一次访问JSP页面时,该页面都会被org.apache.jasper.servlet.JspServlet翻译成一个Servlet源文件(.java),

然后将源文件编译成class文件.Servlet源文件和.class文件都放在"Tomcat安装目录/work/Catalina/localhost/应用名/"目录下.

由JSP文件翻译成的Servlet类带有包名,包名为org.apache.jsp

因此完整的文件路径是:Tomcat安装目录/work/Catalina/localhost/应用名/org/apache/jsp/jsp文件名_jsp.class

```
public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private volatile javax.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
    if (_el_expressionfactory == null) {
      synchronized (this) {
        if (_el_expressionfactory == null) {
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        }
      }
    }
    return _el_expressionfactory;
  }

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
    if (_jsp_instancemanager == null) {
      synchronized (this) {
        if (_jsp_instancemanager == null) {
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        }
      }
    }
    return _jsp_instancemanager;
  }

  public void _jspInit() {
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write('\n');
      out.write("\n");
      out.write("\n");
      out.write("<html>\n");
      out.write("<head>\n");
      out.write("    <title>$Title$</title>\n");
      out.write("</head>\n");
      out.write("<body>\n");
      out.write("当前的时间是：\n");

    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));

      out.write("\n");
      out.write("\n");
      out.write("</body>\n");
      out.write("</html>\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}

```

其中静态页面的HTML输出代码和JAVA动态代码都放在了_jspService()方法内

2. **JspServlet将请求转发到编译后的JSP对应的Servlet,然该Servlet响应请求**.



### JSP语法

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>
当前的时间是：
<%
    //Java代码
    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));
%> 
</body>
</html>
```

**运行输出**

![JSP技术](E:\笔记\JavaWeb\photo\JSP技术.bmp)

#### JSP表达式

JSP表达式用于将程序数据输出到客户端或赋值到参数值上,它将要输出的变量或者表达式直接封装在以

<%=java返回值函数%>标记中

```
<%=new Date().toLocaleString()%>
```

#### JSP脚本片段

JSP脚本片段是指嵌套在<%和%>之中的一条或多条程序代码,这些Java代码必须严格遵守Java语法规范,否则会编译报错。

```
<%
    //Java代码
    out.write("当前时间:");
%> 
<%
    //Java代码
    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));
%> 
```

单个脚本片段的Java语句可以是不完整的，但是，多个脚本片段组合后的结果必须是完整的Java语句。

因为脚本片段的Java代码将原封不动地移到JSP页面所翻译的Servlet的_jspService()方法中。

```
<% int i=1 %>
<% while(i=1) %>
<% 
{
    out.write("helloworld");
}
%>
```



#### JSP声明

当JSP页面被翻译成Servlet程序时，JSP中包含的脚本片段，表达式，模板元素都将转换为Servlet中的_jspService()方法的程序代码。

这时，JSP脚本片段中定义的变量都将称为_jspServce()方法中的局部变量，而JSP脚本片段中定义的方法都将插入

_jspService()方法，从而出现在程序的方法中再定义方法，这样的语法时错误的。

为了解决这样的问题，在JSP技术中提供了声明,

如↓

```
<%! 
Java代码
%>
```

被声明的Java代码都将翻译到Servlet的_jspService()方法值外。

同脚本片段一样，在Jsp页面中也可以由多个JSP声明，单个声明中的Java语句可以时不完整的，但是多个声明组合后的结果必须是完整的Java语句。

#### JSP注释

```
<%-- 注释信息 --%>
```

Tomcat在将JSP页面翻译成Servlet程序时,会忽略JSP页面中被注释的内容,不会将注释的信息发送到客户端



### JSP指令

为了设置JSP页面中的一些信息,SUN公司提供了JSP指令.

JSP2.0中定义了**page**,**include**,**taglib**三种指令.

每一种指令都定义了各自的属性

#### page指令

在JSP页面中,经常需要对页面的某些特性进行描述,例如,**页面的编码方式**,**JSP页面采用的语言**,**类库的引用**...

这时就可以通过page指令来实现

**语法格式**

```
<%page 属性名="属性值" %>
```

**常用属性**

- language

  ```
  <%page language="java" %>
  ```

  指明解释该JSP文件时采用的语言,默认为java

- extends

  ```
  <%page extends="任何类的全名" %>
  ```

  指明编译该JSP文件时继承哪个类

  JSP为Servlet,因此当 指明继承普通类时需要实现Servlet的init(),destory()方法,**一般不会去继承**

- import

  ```
  <%page import="任何包名,类名" %>
  ```

  指定在JSP页面翻译成Servlet源文件中导入的包或类

- session

  ````
  <%page session="true|false" %>
  ````

  指明该JSP内是否内置Session对象.如果为true,则说明内置Session对象,可以直接使用.默认为true

- autoFlush

  ```
  <%page autoFlush="true|false" %>
  ```

  指明是否运行缓存,如果为true,使用out.println()等方法输出的字符串并不立刻到客户端服务器,而是暂时存在缓冲区里,缓存满或者程序执行完毕或者执行out.flush()等操作才会到客户端,

  如果autoFlush=false,那么JSP输出的内容需要自行调用out.flush()方法,将内容输出到response缓存区,不然知道JSP程序结束之后才输出到response.

  默认情况下,autoFlush为true

- buffer

  ```
  <%page buffer="none|数值+kb" %>
  ```

  指定缓存的大小,当autoFlush设为true时才有效

  none=0kb

- isThreadSafe

  ```
  <%page isThreadSafe="true|false" %>
  ```

  指定线程是否安全,如果为**true**,则**多个线程**同时运行该jsp程序,否则只运行**一个线程**,其他线程等待

  默认情况下,isThreadSafe=true

- isErrorPage

  ```
  <%page isErrorPage="true|false" %>
  ```

  指定该页面是否为错误处理页面,如果为true,则该JSP页面内容有一个Exception对象的exception,可以直接使用.默认情况下,isErrorPage=false

- errorPage

  ```\
  <%page errorPage="某个JSP页面的相对路径" %>
  ```

  指定一个错误页面,如果该JSP程序抛出一个未捕获的异常,则转到errorPage指定的页面.error-Page指定的页面的isErrorPage属性为true,且内置的exception对象为未捕获的异常

- contentType

  ```
  <%page contentType="有效的文档类型" %>
  ```

  客户端浏览器根据该属性判断文档类型.例如:

  HTML格式为:text/html

  JPG图像为:image/jpeg

- info

  ```
  <%page info="任何字符串" %>
  ```

  指定JSP的信息,该信息可以通过Sevlet.getServletInfo()方法获取到

  ​

#####JSP输出缓存

**autoFlush(是否将输出内容自动输入到JSP缓存区)**

![out隐式对象的工作原理](E:\笔记\JavaWeb\photo\out隐式对象的工作原理.bmp)

JSP向客户端输出内容,如果设定了autoFlush=true和buffer=缓存值得话

输出内容不会直接输出到response缓存区,而输出到JSP引擎自带的缓存区

**待缓存取满了**或**程序运行结束**在或者调用**out.flush()方法**

才会将内容输出到response缓存区,最后response缓存区的内容才会发送给客户端.

> autoFlush=true , buffer=10kb

```
<%@ page contentType="text/html;charset=UTF-8" language="java"  buffer="10kb" autoFlush="true" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>

<%

    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));
    response.getWriter().write("当前的时间是：");
%>
</body>
</html>
```

![out隐式对象的工作原理02](E:\笔记\JavaWeb\photo\out隐式对象的工作原理02.bmp)

因为response.getWriter().write("")方法是直接将输出内容输入到response缓存区,

而JSP的out隐式对象是将输出内容输入到JSP引擎自带的缓存区,**待缓存区满了**或**自行调用out.flush()**在或者**程序结束后**才将输出内容输入到resopnse缓存区.

因此服务端向客户端输出的内容中**response.getWriter().write("")的输出内容**比**JSP中的out隐式对象输出的内容**先输出.

> autoFlush=true , buffer=0kb

```
<%@ page contentType="text/html;charset=UTF-8" language="java"  buffer="0kb" autoFlush="true" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>

<%

    Date date = new Date();
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
    out.write(simpleDateFormat.format(date));
    response.getWriter().write("当前的时间是：");
%>
</body>
</html>
```

![out隐式对象的工作原理01](E:\笔记\JavaWeb\photo\out隐式对象的工作原理01.bmp)

当autoFlush=true时,JSP输出内容会当缓存区buffer满时,自动刷新到response

因为buffer缓存区的大小为0kb,所以JSP的隐式对象out输出的内容会直接输入到response缓存区

因此服务端向客户端输出的内容中***JSP中的out隐式对象输出的内容***比**response.getWriter().write("")的输出内容**先输出.

- errorPage指定错误页面

> 未指定错误页面,出现异常时

```
<%@ page contentType="text/html;charset=UTF-8" language="java"  buffer="none" autoFlush="true"  %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>

<%
    response.getWriter().write("HelloWrold：");//输出内容
    String s=null;                             //对象为nulll
    s.getBytes();		                      //调用null对象方法
    response.getWriter().write("HelloWrold：");//输出内容
%>
</body>
</html>

```

![errorPage01](E:\笔记\JavaWeb\photo\errorPage01.bmp)

**异常出现后,不在向客户端输出内容**

> 指定错误页面,出现异常时

```
<%@ page contentType="text/html;charset=UTF-8"  language="java"  errorPage="/errorPage.jsp" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>

<%
    response.getWriter().write("HelloWrold：");
    String s=null;
    s.getBytes();
    response.getWriter().write("HelloWrold：");
%>
</body>
</html>

```

![errorPage02](E:\笔记\JavaWeb\photo\errorPage02.bmp)

**JSP页面出现异常后,异常页面转发给错误页面执行**

------

如果为每一个页面都指定一个错误页面,这样的做法显然很烦琐,这时,可以在web.xml文件中使用<error-page>元素

为整个Web应用程序设置错误处理页面

```
    <error-page>
        <error-code>500</error-code>
        <location>/errorPage.jsp</location>
    </error-page>
```

error-code:错误响应状态码

location:错误处理页面



#### include指令

有时候,需要在JSP页面静态包含一个文件,例如HTML文件,文本文件等,这时,可以通过include指令来实现

```
    <%@include file="URL"%>
```

- 被引入的文件必须遵行JSP语法,其中内容可以包括静态HTML,JSP脚本元素和JSP指令等普通JSP页面所具有的一切内容
- 除了指令元素外,被引入的文件中的其他元素都被转换成响应的Java源代码,然后插入进当前JSP页面所翻译成的Servlet源文件中,插入位置与include指令在当前JSP页面的位置保持一致

**也就是说include指令包含的内容是编译时包含**

查看到JSP页面翻译成的Servlet文件中的_jspService()方法中的一段输出内容代码可知

**JSP源文件**

```
<html>
<head>
    <title>$Title$</title>
</head>
<body>


<%out.write("HelloWrold");%>
----------------------------------------------------------------------------------
<%@include file="errorPage.jsp" %>
----------------------------------------------------------------------------------
<%out.write("HelloWrold");%>
</body>
</html>

```

**翻译的Servlet文件**

```
      out.write('\n');
      out.write("\n");
      out.write("\n");
      out.write("<html>\n");
      out.write("<head>\n");
      out.write("    <title>$Title$</title>\n");
      out.write("</head>\n");
      out.write("<body>\n");
      out.write("\n");
      out.write("\n");
      out.write("HelloWrold");
      out.write('\n');
      out.write("\r\n");
      out.write("\r\n");
      ----------------------------------------------------------------------------------
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("    <title>错误页面</title>\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");
      out.write("抱歉，服务器出现异常");
      out.write("\r\n");
      out.write("</body>\r\n");
      out.write("</html>\r\n");
      ----------------------------------------------------------------------------------
      out.write('\n');
      out.write("HelloWrold");
      out.write("\n");
      out.write("</body>\n");
      out.write("</html>\n");

```

#### taglib指令

在进行自定义标签开发中,如果某个JSP文件想使用到该自定义标签的话,就需要导入该标签

其中taglib指令就是导入自定义标签的指令

```
<%@taglib uri="tld文件中url映射路径" prefix="前缀"%>
```

**uri:**在tld文件中的url映射路径

**prefix:**标签前缀.如\<jsp:forward/>中的jsp,一般定义为tld文件名,这样的话比较容易找到对应的自定义标签

**什么是tld文件**

tld:英文全称Tag Library Description,标签库描述文件.声明自定义标签的文件,通过该文件可以映射到自定义标签所对应的类对象,从而调用该对象方法



### JSP隐式对象

在JSP页面中,有一些对象需要频繁使用,如果每次创建这些对象则会非常麻烦.

为此,JSP提供了9个隐式对象,它们是JSP默认创建的,可以直接在JSP页面使用.

- **JspWriter**    out

  用于页面输出,

  **注意的是**,输出对象不同于response输出,JspWriter输出的内容先会输入到自身缓存区

  **待缓存区满了**,或**刷新缓存区**,在者**程序执行结束**后才会将输出内容输入到response缓存区.

  response最终待响应结束将内容response缓存区的内容输出给客户端

- **HttpServletRequest**      request

  得到用户请求信息

- HttpServletResponse       response

  服务器向客户端的回应信息

- **ServletConfig**         config

  服务器配置,可以取得初始化参数

- **HttpSession**        session

  用来保存用户信息

- **ServletContext**       application

  所有用户的共享信息

- **PageContext**          pageContext

  JSP的页面容器

- **Objcect **        page

  指当前页面装换后的Servlet类的实例

- **Throwable**        exception

  表示JSP页面所发生的异常,只在错误页面中才起作用.也就是isErrprPage=true时.

  ​



#### PageContext对象

在JSP页面中,要想获取JSP的隐式对象,还可以使用pageContext对象.它代表当前JSP页面的运行环境,并提供了一系列获取其他隐式对象的方法.

该对象在做自定义标签时可以方便的获取其他隐式对象,并调用其方法

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<html>
<head>
    <title>$Title$</title>
</head>
<body>


<%
    String parameter = pageContext.getRequest().getParameter("name");
    pageContext.getResponse().getWriter().write(parameter);
%>


</body>
</html>

```

![pageContext](E:\笔记\JavaWeb\photo\pageContext.bmp)

##### PageContext对象的应用

> pageContext存储数据

pageContext对象不仅提供了获取隐式对象的方法,还提供了存储数据的功能.

pageContext对象存储数据是通过操所属性来实现的

- void setAttribute(String name,Object value,int scope)

  设置pageContext对象的属性

- Object getAttribute(String name,int scope)

  获取pageContext对象的属性

- void removeAttribute(String name,int scope)

  删除指定范围内名称为name的属性

- void removeAttribute(String name)

  删除所有范围内名称为name的属性

- Object findAttribute(String name)

  从四个域对象中查找名称为name的属性

**域对象**

- pageContext.PAGE_SCOPE:表示页面范围


- pageContext.REQUEST.SCOPE:表示请求范围


- pageContext.SESSION.SCOPE:表示会话范围

- pageContext.APPLICATION.SCOPE:表示Web应用程序范围

  

当使用findAttribute()方法查找名称为name的属性时,会按照page,requset,session,application(ServletContext)

范围从小到大查找,如果找到返回属性名称的值,停止查找.否则返回null.



### 原生JSP标签

JSP页面中可以嵌套一些java代码来完成某种功能,但是这种java代码会使JSP页面很乱,不利于美工调试和维护.

为了减少JSP页面中的Java代码,Sun公司允许在JSP页面中嵌套一些标签,这些标签可以完成各种通用的JSP页面功能,

被称为JSP标签.

#### <jsp:include>标签

在JSP页面中,为了把其他资源的输出内容插入到当前JSP页面的输出内容中,JSP技术提供了\<jsp:include\>标签

**语法格式**

```
<jsp:include page="引用资源相对路径" flush="true|false">
```

page:指定被引入资源的相对路径

flush:指定当前页面的输出内容是否刷新到客户端,默认情况下,flush=false

**flush=true:**include标签之前输出的内容不等待include标签中引用的资源执行输出,而先输出到客户端

**flush=false:**include标签之前输出的内容等待include标签中引用的资源执行输出,待引用资源中的程序执行结束后,一块输出到客户端.



#####  <jsp:include>标签与include指令的区别

- include标签中引入的资源和当前JSP页面是两个彼此独立的执行实体,即被动态引入的必须能够被Web容器独立执行.

  而include指令只能引用遵循JSP格式的文件,被引入的文件与JSP文件需要共同合并才能翻译成一个Servlet源文件

- include标签中引用的资源是在运行才包含的,而且只包含运行结构

  include指令引入的资源实在编译时期包含的,包含的是源代码

- include标签运行原理与RequestDispatcher.include方法类似,即被include引用的页面不能改变响应状态码或者设置响应头,而include指令没有这方面的限制



#### <jsp:forward>标签

在JSP页面中,经常需要将请求转发给另外一个资源,这时,除了RequestDispatcher接口的forward()方法可以实现外,还可以通过<jsp:forward>标签来实现.

```
<jsp:forward page="请求转发资源路径"/>
```

查看翻译后的Servlet源文件后,可知

<jsp:forward>标签被翻译成了调用pageContext.forward方法的语句,并在调用pageConext.forward()方法后使用return语句结束了service()方法的执行流程,从而不在执行<jsp:forward>标签后面的语句.



### 自定义JSP标签

#### 简介

自定义标签主要用于移除JSP页面中的java代码,将程序java代码封装到其他地方,最后在JSP引用该自定义标签时,在将这些源java代码打包进Servlet方法中.

##### 自定义标签的其他用途

- 控制jsp页面某一部分内容是否执行
- 控制整个jsp页面是否执行
- 控制jsp页面内容重复执行
- 修改jsp页面内容输出

**实现步骤**

1. 编写一个实现Tag接口的java类，把页面的java代码移到这个Java类中中的方法
2. 编写标签库描述文件（.tld）,在tld文件中对标签处理器描述成一个标签

根据J2EE版本历史，实现自定义标签有很多种实现方法

J2EE2.0之前我们叫**传统自定义标签**和**简单自定义标签**

#### tld(标签库描述文件)

##### 简介

tld:英文全称Tag Library Description,标签库描述文件.声明自定义标签的文件,通过该文件可以映射到自定义标签所对应的类对象,从而调用该对象方法

在WEB-INF文件目录下创建标签库描述文件,文件后缀为".tld",名字可以随意,但一般最好根据自定义标签功能意义取名

    <?xml version="1.0" encoding="ISO-8859-1"?>
    
    <taglib xmlns="http://java.sun.com/xml/ns/javaee"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd"
            version="2.1">
    
    <tlib-version>1.0</tlib-version>
    <short-name>myshortname</short-name>
    <uri>http://jr.com</uri>
    
    <tag>
        <description>用TagSupport实现自定义标签</description>
        <name>tagsupport</name>
        <tag-class>tag.My_TagSupport</tag-class>
        <body-content>empty</body-content>
    </tag>
    </taglib>
- tlib-version:标签描述库版本

- short-name:该标签描述库短名称

- uri:外部JSP页面导入映射该标签描述库的uri

- tag:声明一个自定义标签

  - description:该自定义标签的描述

  - name:该自定义标签的映射key

  - tag-class:该自定义标签的实现对象完整路径

  - body-content:该自定义标签是否需要存在内容,如

    ```
    <a> 内容 </a>
    ```

    [^empty]: 空标记，即起始标记和结束标记之间没有内容。
    [^scriptless]: 接受文本、EL和JSP动作,默认取值.
    [^JSP]: 接受所有JSP语法，如定制的或内部的tag、scripts、静态HTML、脚本元素、JSP指令和动作。
    [^tagdependent]: 标签体内容直接被写入BodyContent，由自定义标签类来进行处理，而不被JSP容器解释.

- attribute:为自定义标签元素添加属性

#### 传统自定义标签

自定义标签底层主要是实现Tag接口

并根据需求实现Tag接口中的各个方法

```
public class Tag01 implements Tag {
    @Override
    public void setPageContext(PageContext pageContext) {
        
    }

    @Override
    public void setParent(Tag tag) {

    }

    @Override
    public Tag getParent() {
        return null;
    }

    @Override
    public int doStartTag() throws JspException {
        return 0;
    }

    @Override
    public int doEndTag() throws JspException {
        return 0;
    }

    @Override
    public void release() {

    }
}

```

##### Tag接口方法

根据JSP引擎解析调用自定义标签的流程，JSP引擎将自定义标签中的方法按顺序进行调用

- void setPageContext(PageContext pageContext)

  首先在解析自定义标签时，JSP引擎将整个JSP页面的PageContext对象传递给自定义标签对象，也就相当于将JSP页面中的所有9大隐式对象都传递给了自定义标签。

- void setParent(Tag tag)

  有时候自定义标签外层还有可能嵌套对一层标签，如↓

  ```
  <a>
  	<b/>
  </a>
  ```

  JSP引擎在执行自定义标签时，会将外部嵌套的标签传递给自定义标签内

- Tag getParent()

  内部可以通过该方法得到外部嵌套标签对象

- int doStartTag()

  ```
  <a>
  </a>
  ```

  JSP引擎解析自定义标签中的**<a>**部分时会调用doStartTag()方法

- doEndTag()

  ```
  <a>
  </a>
  ```

  JSP引擎解析自定义标签中的**</a>**部分时会调用doEndTag()方法

- release（）

  当执行完自定义标签后，JSP引擎可能会调用该方法。将该自定义标签对象进行销毁。

  如果该自定义标签被多次调用，那么JSP引擎指定完该标签后，不会以及将它销毁，暂时保存该实例对象到内存，供下次调用.

##### 实现Tag接口对象

由于实现Tag接口来实现自定义标签相对比较烦琐,一般可以使用继承实现了Tag接口的对象

------



###### TagSupport

内部实现了Tag接口,做自定义标签时,根据自己的需要重写特定的TagSupport方法

1. 继承TagSupport

```
public class My_TagSupport extends TagSupport {
    @Override
    public int doStartTag() throws JspException {
        pageContext.setAttribute("attribute", new String("继承TagSupport自定义标签<br/>并在               doStartTag中传递数据<br/>doEndTag中获取数据"));
        return super.doStartTag();
    }

    @Override
    public int doEndTag() throws JspException {
        String attribute = (String) pageContext.getAttribute("attribute");
        try {
            pageContext.getResponse().getWriter().write(attribute);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return super.doEndTag();
    }
}

```

2. 在创建标签库描述文件(.tld)

```
<tag>
    <description>用TagSupport实现自定义标签</description>
    <name>tagsupport</name>
    <tag-class>tag.My_TagSupport</tag-class>
    <body-content>empty</body-content>
</tag>
```

3. 在JSP页面中导入并引用该自定义标签
   1. 使用taglib指令导入标签库描述文件
   2. 引用该自定义标签

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%-- 使用taglib指令导入标签库描述文件 --%>
<%@taglib prefix="mytag" uri="http://jr.com" %>

<html>
<head>
    <title>测试</title>
</head>
<body>

<%-- 引用该自定义标签 --%>
<mytag:tagsupport></mytag:tagsupport>

</body>
</html>

```

**运行test.jsp结果**

![自定义标签_TagSupport](E:\笔记\JavaWeb\photo\自定义标签_TagSupport.bmp)

**TagSupport的应用**

- 在doStartTag控制自定义标签内容是否执行
- 在doEndTag控制自定义标签余下的JSP内容是否执行

- 控制jsp页面内容重复执行

**返回值常量**

[^TAG.EVAL_BODY_INCLUDE]: 执行标签体内容
[^TAG.SKIP_BODY]: 不执行标签体内容
[^TAG.EVAL_PAGE]: 执行标签余下JSP内容
[^TAG.SKIP_PAGE]: 不执行标签余下JSP内容
[^IterationTag.EVAL_BODY_AGINE]: 继续执行标签体内容
[^BodyTag.EVAL_BODY_BUFFERED与BodyTag.EVAL_BODY_TAG]: 如果在doStartTag（）方法中，返回EVAL_BODY_BUFFERED或者EVAL_BODY_TAG,那么JSP引擎会调用setBodyContent（）方法，将标签体内容封装成一个对象参数给setBodyContent（）传递给该自定义标签对象



**实现控制标签体内容**

- **执行标签体内容（返回Tag.EVAL_BODY_INCLUDE）**

>  重写TagSupport方法

```
public class My_TagSupport extends TagSupport {
    @Override
    public int doStartTag() throws JspException {
        return Tag.EVAL_BODY_INCLUDE;
    }

    @Override
    public int doEndTag() throws JspException {
        return super.doEndTag();
    }
}
```

>  声明自定义标签，允许存在标签体内容

```
    <tag>
        <description>用TagSupport实现自定义标签</description>
        <name>tagsupport</name>
        <tag-class>tag.My_TagSupport</tag-class>
        <body-content>JSP</body-content>    //允许存在标签体内容
    </tag> 
```

>  引用自定义标签

```
<%@ page contentType="text/html;charset=UTF-8"language="java" %>
<%@taglib prefix="mytag" uri="http://jr.com" %>
<html>
<head>
    <title>测试</title>
</head>
<body>
<mytag:tagsupport>
    标签体内容
</mytag:tagsupport>
</body>
</html>
```

>  执行JSP页面

![自定义标签控制JSP内容](E:\笔记\JavaWeb\photo\自定义标签控制JSP内容.bmp)

**可以看到标签体内容被JSP引擎执行了**

------

- **不执行标签体内容（返回Tag.SKIP_BODY）**

> 在以上代码基础上修改doStartTag（）方法返回值

```
public class My_TagSupport extends TagSupport {
    @Override
    public int doStartTag() throws JspException {
        return Tag.SKIP_BODY;
    }

    @Override
    public int doEndTag() throws JspException {
        return super.doEndTag();
    }
}
```

>  执行JSP页

![自定义标签控制JSP内容01](E:\笔记\JavaWeb\photo\自定义标签控制JSP内容01.bmp)



**可以看到标签体内容没有被JSP引擎执行**

------

- **执行自定义标签余下内容(返回Tag.EVAL_PAGE)**

> 重写TagSupport方法

```
public class My_TagSupport extends TagSupport {
    @Override
    public int doStartTag() throws JspException {
        return super.doStartTag();
    }

    @Override
    public int doEndTag() throws JspException {
        return Tag.EVAL_PAGE;
    }
}
```

> 引用自定义标签

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@taglib prefix="mytag" uri="http://jr.com" %>
<mytag:tagsupport/>

<html>
<head>
    <title>测试</title>
</head>
<body>
</body>
</html>
```

> 执行JSP页面

![自定义标签控制JSP内容02](E:\笔记\JavaWeb\photo\自定义标签控制JSP内容02.bmp)

可以看到自定义标签余下的JSP内容被JSP引擎执行了

- **不执行自定义标签余下内容(返回Tag.SKIP_PAGE)**

> 在以上基础上在修改doEndTag（）方法中返回值

```
public class My_TagSupport extends TagSupport {
    @Override
    public int doStartTag() throws JspException {
        return super.doStartTag();
    }

    @Override
    public int doEndTag() throws JspException {
        return Tag.SKIP_PAGE;
    }
}
```

> 执行JSP页面

![自定义标签控制JSP内容03](E:\笔记\JavaWeb\photo\自定义标签控制JSP内容03.bmp)

**可以看到自定义标签余下的JSP内容没有被JSP引擎执行**

------

- **控制执行标签体内容次数**

TagSupport类除了实现Tag接口的方法，还实现了继承Tag接口的IterationTag接口方法。

IterationTag接口在Tag接口的基础上添加了**一个返回值常量**，**一个方法**

```
public interface IterationTag extends Tag {
    int EVAL_BODY_AGAIN = 2;

    int doAfterBody() throws JspException;
}
```

**用于实现控制执行标签体内容次数**

>  **doAfterBody()**

该方法在执行在**标签体内容被执行之后**，**标签执行完之前（doEndTag）**

只要标签体内容被JSP引擎执行就会调用该方法

可根据方法返回值控制标签体内容执行次数

> **EVAL_BODY_AGAIN常量**

继续执行标签体内容

**实现**

> 重写TagSupport方法

为了让doAfterBody（）方法得到执行，在doStartTag（）方法返回值必须为Tag.EVAL_BODY_INCLUD或BodyTagSupport.EVAL_BODY_BUFFERED

让JSP引擎执行标签体内容

```
public class My_TagSupport extends TagSupport {
    @Override
    public int doStartTag() throws JspException {
        return IterationTag.EVAL_BODY_INCLUDE;
    }

    int account = 0;

    @Override
    public int doAfterBody() throws JspException {
        System.out.println(pageContext.getPage().toString());
        if (account < 6) {
            account++;
            return IterationTag.EVAL_BODY_AGAIN;
        } else {
            return IterationTag.SKIP_BODY;
        }
    }

    @Override
    public int doEndTag() throws JspException {
        return super.doEndTag();
    }
}
```

**在doAfterBody（）方法中，直到该方法返回SKIP_BODY，否则返回EVAL_BODY_AGAIN会继续执行标签体中的内容。**

> 执行JSP内容

![自定义标签控制JSP内容04](E:\笔记\JavaWeb\photo\自定义标签控制JSP内容04.bmp)

**看到标签体中的内容被执行了多次**

------

###### BodyTagSupport

**简介**

在TagSupport类中，实现继承了Tag接口的IterationTag接口，从而可以控制三种JSP页面内容效果

但仍然是不能够满足自定义标签的所有功能需求

实现修改标签体内容

所以在IterationTag的基础上，多了一个BodyTag接口

```
public interface BodyTag extends IterationTag {
    int EVAL_BODY_TAG = 2;
    int EVAL_BODY_BUFFERED = 2;

    void setBodyContent(BodyContent var1);

    void doInitBody() throws JspException;
}
```

实现该接口的方法可以达到修改标签体内容的需求

**BodyTag新添加属性**

- EVAL_BODY_BUFFERED与EVAL_BODY_TAG

  如果在doStartTag（）方法中，返回EVAL_BODY_BUFFERED或者EVAL_BODY_TAG

  那么JSP引擎会调用setBodyContent（）方法，将标签体内容封装成一个对象参数给setBodyContent（）传递给该自定义标签对象

  EVAL_BODY_TAG是一个过时的常量。被EVAL_BODY_BUFFERED所替代。

- void setBodyContent（）

  JSP引擎内部调用该方法，将标签体内容传递给该对象

  在doStartTag（）方法之后，doAfterTag（）方法之前调用

  之后可以通过getBodyContent()方法获取到该标签体对象内容，根据需求修改后在输出

**实现BodyTag接口修改标签体内容**

>  由于直接实现BodyTag接口相对比较麻烦,最简单的方法就是直接继承实现了BodyTag接口的类

```
public class My_BodyTagSupport extends BodyTagSupport {
    @Override
    public int doStartTag() throws JspException {
        return BodyTagSupport.EVAL_BODY_BUFFERED;
    }

    @Override
    public int doEndTag() throws JspException {
    //获取标签体内容
        String date = getBodyContent().getString();
        try {
            //将标签体内容小写转大写    
            pageContext.getOut().write(date.toUpperCase());
        } catch (IOException e) {
            throw new RuntimeException();
        }
        return super.doEndTag();
    }
}

```

> 引用自定义标签

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@taglib prefix="mytag" uri="http://jr.com" %>


<html>
<head>
    <title>测试</title>
</head>
<body>
<mytag:my_bodytagsupport>aaaaaa</mytag:my_bodytagsupport>
</body>
</html>
```

> 执行jsp页面

![自定义标签控制JSP内容05](E:\笔记\JavaWeb\photo\自定义标签控制JSP内容05.bmp)



**可以看到标签体内容aaaaa被修改为了大写AAAAAA后在输出**

------

##### 总结

- 自定义标签流程

![自定义标签流程](E:\笔记\JavaWeb\photo\自定义标签流程.jpg)



- 自定义标签方法执行流程

1. setPageContext（）

2. setParent（）

3. doStartTag（）

4. 如果doStartTag（）return **EVAL_BODY_INCLUDE**会调用doAfterBody（）

5. 如果doStartTag（）return **EVAL_BODY_BUFFERED**会调用setBodyContent后在调用doAfterBody（）

6. doEndTag（）

7. release（）

   

- 控制JSP页面内容

1. 控制部分jsp内容重写doStartTag（），返回Tag.EVAL_BODY_INCLUDE或Tag.SKIP_BODY

2. 控制部分标签余下jsp内容重写doEndTag（）,返回Tag.EVAL_PAGE或Tag.SKIP_PAGE

3. 控制jsp内容执行次数

   重写doStartTag（）返回Tag._EVAL_BODY_INCLUND

   和doAfterBody（）返回Tag._EVAL_BODY_AGINE或Tag.SKIP_BODY

4. 修改jsp内容重写doStartTag（）返回BodyTagSupport.EVAL_BODY_BUFFERED

   和doEndTag（）获取标签体内容对象，在根据需求修改内容输出

   

##### body-content属性值

- **empty：空标记，即起始标记和结束标记之间不允许存在内容。** 

```
<mytag:my_bodytagsupport>
内容
</mytag:my_bodytagsupport>
```

如果标签体存在内容，服务内容会报异常

![body-content属性值_empty](E:\笔记\JavaWeb\photo\body-content属性值_empty.bmp)

- **JSP：接受所有JSP语法，如定制的或内部的tag、scripts、静态HTML、脚本元素、JSP指令和动作。** 

  > **包含JSP指令**

  标签体内容取程序运行时的动态值

  ```
  <mytag:my_bodytagsupport>
  <%=request.getContextPath()%>
  </mytag:my_bodytagsupport>
  ```

  然后在标签器类中获取标签体内容并输出到客户端

  ```
      @Override
      public int doEndTag() throws JspException {
          try {
              pageContext.getOut().write(getBodyContent().getString());
          } catch (IOException e) {
              throw new RuntimeException();
          }
          return super.doEndTag();
      }
  ```

  结果

  ![body-content属性值_JSP](E:\笔记\JavaWeb\photo\body-content属性值_JSP.bmp)

  

  >  **包含JSP脚本片段**

  也可以在标签体内容中编写JSP表达式（JAVA代码）

  ```
  <mytag:my_bodytagsupport>
      <%-- 声明了返回HelloWorld字符串方法 --%>
      <%! public java.lang.String printHelloWorld() {
          return "HelloWrold";
      }%>
      <%-- 向客户端输出HelloWorld方法 --%>
      <% out.write(printHelloWorld());%>
  </mytag:my_bodytagsupport>
  ```

  结果

  ![body-content属性值_JSP01](E:\笔记\JavaWeb\photo\body-content属性值_JSP01.bmp)

  > 包含JSP动作元素

  ```
  <mytag:eval_body_inclund>
      <jsp:include page="include_jsp.jsp"/>            <!-- JSP动作元素 -->
      <br/>
      我是自定义标签里面的内容
  </mytag:eval_body_inclund>
  ```

  结果

  ![body-content属性值_scriptless](E:\笔记\JavaWeb\photo\body-content属性值_jsp06.bmp)

  执行了JSP动作元素中的include，将其他jsp文件包含进来了

- **tagdependent：标签体内容直接被写入BodyContent，由自定义标签类来进行处理，而不被JSP引擎解释. **

  也就是说在标签体里面写的内容仅仅只被当初字符串，不会JSP引擎解释

  ```
  <mytag:my_bodytagsupport>
  <%=request.getContextPath()%>
  </mytag:my_bodytagsupport>
  ```

  结果

  ![body-content属性值_tagdependent](E:\笔记\JavaWeb\photo\body-content属性值_tagdependent.bmp)

  可以看到直接输出了标签体内的JSP指令

  

- scriptless: 标签体可以包含EL表达式和JSP动作元素，但不能包含JSP的脚本元素

  > 注意！！！

  ```
  <mytag:simpletag_05>
      <% response.getWriter().println("HelloWrold");%>
  </mytag:simpletag_05>
  ```

  结果

  ![body-content属性值_scriptless](E:\笔记\JavaWeb\photo\body-content属性值_scriptless.bmp)

  不会够执行jsp脚本片段

##### 设置标签参数

- 在标签处理器类中编写每个属性对应的setter方法

```
public class My_Tag_HasAttribute extends TagSupport {
    boolean attribute;
    //编写每个属性的setter方法
    public void setAttribute(boolean attribute) {
        this.attribute = attribute;
    }

    @Override
    public int doStartTag() throws JspException {
        try {
            //输出参数
            pageContext.getOut().write(String.valueOf(attribute));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return super.doStartTag();
    }
}
```

- 在tld文件中描述标签属性

```
<tag>
    <name>has_attribute_tag</name>
    <tag-class>tag.My_Tag_HasAttribute</tag-class>
    <body-content>empty</body-content>
    <attribute>
        <name>attribute</name>
        <required>true</required>
        <rtexprvalue>true</rtexprvalue>
        <type>int</type>
    </attribute>
</tag>

```

[^name]: 参数名，必须和自定义标签器中的属性名一致
[^required]: 是否必须设置该参数
[^rtexprvalue(Run Time Expr Value)]: 运行时表达式值（JSP表达式、el表达式...）该参数值是否可以为运行时表达式值

```
<mytag:has_attribute_tag attribute="<%=request.getRequestURI() %>">
</mytag:has_attribute_tag>
```

[^type]: 声明该参数类型

**运行结果**

![设置自定义标签参数](E:\笔记\JavaWeb\photo\设置自定义标签参数.bmp)

**小技巧**

观察到在标签中设置的参数都是字符串类型的，而在标签器类中声明的却是其他类型的属性参数

那是因为JSP引擎内容进行转换

但能转换的仅仅只是八大基本数据类型与字符数之间才能转换

要想在参数中赋其他类型的话，只能通过运行时表达式进行赋值,如

```
public class My_Tag_HasAttribute extends TagSupport {
    Date attribute;

    public void setAttribute(Date attribute) {
        this.attribute = attribute;
    }

    @Override
    public int doStartTag() throws JspException {
        try {
            //输出参数
            pageContext.getOut().write(String.valueOf(attribute));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return super.doStartTag();
    }
}
```

```
<mytag:has_attribute_tag attribute='<%=new Date() %>'>
</mytag:has_attribute_tag>
```

**注意设置参数值类型必须和标签器类中定义的类型一致**

**而且value中的“”(双引号)需要换成''(单引号)**

![设置自定义标签参数01](E:\笔记\JavaWeb\photo\设置自定义标签参数01.bmp)



#### 简单自定义标签

由于传统自定义标签定义标签比较烦琐，为规范统一接口来自定义标签，在J2EE2.0出现了简单自定义标签

相对传统自定义标签，简单自定义标签省去了在继承不同接口实现不同标签用途的做法，便捷很多

**简单标签接口**

```
public interface SimpleTag extends JspTag {
    void doTag() throws JspException, IOException;

    void setParent(JspTag var1);

    JspTag getParent();

    void setJspContext(JspContext jspcontext);

    void setJspBody(JspFragment jspfragment);
}

```

>  标签体执行流程顺序

- void setJspContext(JspContext jspcontext);

  与传统标签类似，简单标签在执行开始会将JSP页面环境（PageContext）传递给自定义标签器类

  JspContext==PageContext

- void setJspBody(JspFragment jspfragment);

  与传统标签不一样的是，简单标签中只有doTag（）方法处理整个周期逻辑

  在开始执行标签之前，JSP引擎会将标签体内容封装成一个JspFragment对象传入标签器类

  那么在doTag（）方法，可以通过getJspFragment（）方法获取到JspFragment对象

  根据需求对标签体进行操作（修改亦或是执行）

- void setParent(JspTag jspTag);

  如果自定义标签外部有父标签，那么在标签执行之前JSP引擎会通过setParent（）传入标签器类

- void doTag()

  处理整个自定义标签逻辑

> JspFragment API

- void invoke(Writer writer)

  将标签体内容输入到一个输出流

- JspContext getJspContext（）

  获取JSP页面环境对象（PageContext）



##### 应用

同样由于直接实现SimpleTag接口比较烦琐，最简单的就是直接继承该接口实现类**SimpleTagSupport**

- 控制执行标签体内容

  ```
      @Override
      public void doTag() throws JspException, IOException {
          super.doTag();
          JspFragment jspFragment = getJspBody();//获取标签体对象
          jspFragment.invoke(getJspContext().getOut());//执行标签体内容
       }  
      
  ```

  jspFragment.invoke()根据传入参数输出流，将标签体内容输出到哪

  如果不执行invoke（getJspContext().getOut()）方法，则标签体将不输出到客户端



- 修改标签体内容后在执行

  ```
  @Override
  public void doTag() throws JspException, IOException {
      super.doTag();
      JspFragment jspFragment = getJspBody();//获取标签体对象
      PageContext pageContext = (PageContext) jspFragment.getJspContext();//获取JSP页面隐式对象
      StringWriter stringWriter = new StringWriter();//创建缓存String输出流，用来存放标签体内容
      String date=stringWriter.toString();//获取缓存流数据
      date.toUpperCase();//修改数据
      //...根据需求是否执行标签体内容
  }
  ```

- 执行多次标签体内容

  ```
      @Override
      public void doTag() throws JspException, IOException {
          super.doTag();
          System.out.println("doTag");
          JspFragment jspFragment = getJspBody();
          for (int i = 0; i < 6; i++) {
              jspFragment.invoke(getJspContext().getOut());
          }
      }
  
  ```

- 不执行标签余下JSP内容

  ```
  @Override
      public void doTag() throws JspException, IOException {
          super.doTag();
          throw new SkipPageException();
      }
  ```

  如果在doTag（）方法中抛出SkipPageException异常，那么余下的JSP内容不会被执行

**可以看到，在自定义标签中，所以的业务逻辑都放在了doTag（）方法中**



#### 自定义函数标签

- 自定义函数标签

  将一个**静态**方法标记成一个标签，在JSP页面中可通过标记标签进而调用**静态**方法

  **步骤**

  1.在类中创建静态方法

  ```
  public class tag_function {
      public static int indexOf(String input, String substring) {
          if (input == null) {
              input = "";
          }
          if (substring == null) {
              substring = "";
          }
          return input.indexOf(substring);
      }
  }
  ```

  2.在tld标签库描述文件中声明

  ```
      <function>
          <description>指定字符在字符串中的位置</description>
          <name>indexOf</name>
          <function-class>tag.function.tag_function</function-class>
          <function-signature>int indexOf(java.lang.String,java.lang.String)</function-signature>
          <example>${tag_function:indexOf("HelloWrold","W")}</example>
      </function>
  ```

  [^function]: 声明静态方法
  [^description]: 描述方法
  [^name]: 标签方法名
  [^function-class]: 该静态方法存在类的路径
  [^function-signature]: 指定该类中某一静态方法
  [^exmple]: 使用该标签方法示例

  

  3.在JSP文件中引用

  ```
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <%@taglib prefix="my_function" uri="http://jr.com" %>
  <html>
  <head>
      <title>el表达式使用java静态方法</title>
  </head>
  <body>
  <li>el调用自定义函数标签:indexOf(),指定字符在字符串中的位置</li>
  indexOf("HelloWrold", "W"):
  <c:out value='${my_function:indexOf("HelloWrold", "W")}'></c:out>
  </body>
  </html>
  ```

  **运行JSP文件**

![自定义函数标签](E:\笔记\JavaWeb\photo\自定义函数标签.bmp)

# EL表达式

###简介

使得JSP页面更直观，写法更简单。如↓

在自定义标签中的参数设置时，需要使用jsp表达式动态设置参数值

```
<% pageContext.setAttribute("age", "17"); %>
<mytag:simpletag_05 attribute='<%=java.lang.String.valueOf(pageContext.getAttribute("age")) %>'>
</mytag:simpletag_05>
```

那么此时就可以用到EL表达式，让整个JSP页面看起来整洁许多

```
<% pageContext.setAttribute("age", "17"); %>
<mytag:simpletag_05 attribute='${age}'>
</mytag:simpletag_05>
```

**可以看到attribute参数动态设置值时非常简洁**

###EL表达式用途

- **从Web域中获取数据**

> web域（pageContext，request，session，servletContext）中检索指定 name的值,按照域大小查询，查到返回指定值，查不到返回“”

```
<%-- 向pageContext设置属性 --%>
<% pageContext.setAttribute("age", "17"); %>
<mytag:simpletag_05 attribute='${age}'><%-- 使用el表达式获取pageContext中的属性 --%>
</mytag:simpletag_05>
```

> 获取bean的属性 

```
<%
    Person person = new Person();
    person.setName("jr");
    request.setAttribute("person", person);
%>
<c:out value='${person["name"]}' default="name"></c:out>
```

> 获取map集合的数据 

```
<%
    Map<String, String> map = new HashMap<String, String>();
    map.put("a", "aaaax");
    map.put("b", "bbbbx");
    map.put("1", "ccccx");

    request.setAttribute("map", map);
%>
${map.a},
${map["1"] }  <!-- 以数字为关键字时候的取法 -->
```

- **执行运算**

  ```
  <%!
      String name = null;
  %>
  不等于null :
  <c:out value='${name!=null}'></c:out> <br>
  等于null :
  <c:out value='${name==null}'></c:out> <br>
  </body>
  
  ```
  > 关系运算判断

  ```
  <%!
      String name = null;
  %>
  不等于null :
  <c:out value='${name!=null}'></c:out> <br>
  等于null :
  <c:out value='${name==null}'></c:out> <br>
  <li>逻辑运算符</li>
  ```
  >  逻辑运算判断

  ```
  <%!
      boolean a =true;
      boolean b =true;
  %>
  <c:out value='${a&&b}'></c:out>
  ```
  > 验证运算判断

  ```
  <%!
      String isempty01 = "no_empty";
      String isempty02 = null;
      String isempty03 = "";
  %>
  是否为empty:<ba>
  <c:out value='${empty isempty01}'></c:out><br>
  <c:out value='${empty isempty02}'></c:out><br>
  <c:out value='${empty isempty03}'></c:out><br>
  ```


![EL隐式对象](E:\笔记\JavaWeb\photo\el表达式运算符.bmp)

- **在el表达式中获取隐式对象信息**

  ![EL隐式对象](E:\笔记\JavaWeb\photo\EL隐式对象.bmp)

  > 获取请求参数值

  ```
  <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <html>
  <head>
      <title>获取隐式对象</title>
  </head>
  <body>
  <c:out value='${param.getOrDefault("name","jr")}'></c:out>
  </body>
  </html>
  ```

  结果

  ![el表达式_获取请求参数](E:\笔记\JavaWeb\photo\el表达式_获取请求参数.bmp)

- **调用静态Java方法**

  > 调用JSTL函数标签

  ```
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
  <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <html>
  <head>
      <title>el表达式使用java静态方法</title>
  </head>
  <body>
  <li>el调用JSTL函数标签:indexOf(),指定字符在字符串中的位置</li>
  indexOf("HelloWrold", "W"):
  <c:out value='${fn:indexOf("HelloWrold", "W")}'></c:out>
  </body>
  </html>
  ```

  > 调用自定义函数标签

  ```
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <%@taglib prefix="my_function" uri="http://jr.com" %>
  <html>
  <head>
      <title>el表达式使用java静态方法</title>
  </head>
  <body>
  <li>el调用自定义函数标签:indexOf(),指定字符在字符串中的位置</li>
  indexOf("HelloWrold", "W"):
  <c:out value='${my_function:indexOf("HelloWrold", "W")}'></c:out>
  </body>
  </html>
  
  ```

  **两者执行效果**

  ![el表达式_执行函数](E:\笔记\JavaWeb\photo\el表达式_执行函数.bmp)

### **.**与**[]**运算符

- 通常情况下是通用的\${user.name}和\${user["sex"]}

  "[]"还可以进行集合元素的定位${booklist[0].price}

- 两种情况下除外

  1.包含特殊字符

  \${user.first-name}                 **无效**

  \${user["first-name"]}             **有效**

  2.通过变量动态取值

  



# JSTL

###简介

JSTL（Java Standard Tag Library）是SUN公式提供的定制标签库集

基于自定义标签原理，重复率高的代码块支持服用，提高效率

书写JSP页面时可读性更强

### 如何使用JSTL

1. 首先在apache官网中下载JSTLjar包[下载链接](http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/)

2. 根据需求下载jar包（jakarta-taglibs-standard-1.1.2.zip）

3. 解压压缩包

   ![jstl压缩包](E:\笔记\JavaWeb\photo\jstl压缩包.bmp)

4. 将lib目录下的两个jar拷到本地项目中的lib目录下并引用这两个jar包

   ![引入JSTLjar包](E:\笔记\JavaWeb\photo\引入JSTLjar包.bmp)

5. 在JSP文件中使用taglib指令引用JSTL标签库

   ```
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <%@taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
   <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
   <html>
   <head>
       <title>使用JSTL</title>
   </head>
   <body>
   <li>el调用JSTL函数标签:indexOf(),指定字符在字符串中的位置</li>
   indexOf("HelloWrold", "W"):
   <c:out value='${fn:indexOf("HelloWrold", "W")}'></c:out>
   <ba/>
   </body>
   </html>
   ```

   

###JSTL分类

根据功能JSTL分为五大标签库

- **核心标签库**

  对应在standard.jar中的META_INF文件中的tld标签库描述文件对应为c.tld

  其中c_1_0.tld和c-1_0-rt.tld为老版本标签库，为了兼容旧项目而存在，一般不必理会

- **JSTL函数标签库**

  对应在standard.jar中的META_INF文件中的tld标签库描述文件对应为fn.tld

- **国际化标签库**

  对应在standard.jar中的META_INF文件中的tld标签库描述文件对应为fmt.tld

  其中fmt-1_0.tld和fmt-1_0-rt.tld同样为老版本标签库

- **数据标签库**

  对应在standard.jar中的META_INF文件中的tld标签库描述文件对应为sql.tld

  其中sql-1_0.tld和sql-1_0-rt.tld同样为老版本标签库

- **XML标签库**

  对应在standard.jar中的META_INF文件中的tld标签库描述文件对应为x.tld

  其中x-1_0.tld和x-1_0-rt.tld同样为老版本标签库



#### 核心标签库

- out标签

  ```
  <c:out value='' default="" escapeXml=""></c:out>
  ```

  > 输出常量到客户端

  可在value属性中直接赋值

  > 输出变量到客户端

  变量不存在时可配合default属性输出默认值，还可以通过escapeXml转义字符的输出方式

  **何为转义？**

  如果想让浏览器直接显示服务端发送给客户端的<a>我是链接</a>的话

  需要对<a>标签进行转义

  这样在浏览器解析到该数据不会把它当html标签进行转换

- set标签

  ```
  <c:set value="" var="" scope="" target=""  property=""></c:set>
  ```

  > 存值到scope（四个Web域：PageContext,request,session,ServletContext）中

  ```
  <c:set value="jr" var="name" scope="page" ></c:set>
  ```

  [^value]: 设置值
  [^var]: 保存变量名
  [^scope]: 指定保存域

  > 存值到JavaBean的属性中

  ```
  <c:set value="jr" target="${person}" property="name"></c:set>
  ```

  [^value]: 设置值
  [^target]: 赋值对象,需要使用运行时表达式设置
  [^property]: 赋值对象属性

  

- remove标签

  > 去掉某个变量

  ```
  <c:remove var="" scope=""></c:remove>
  ```

  [^var]: 指定去掉变量的变量名
  [^scope]: 指定在哪个域中去除,如果不指定，那么会从四个域中检索var的变量名，从而去掉变量






# 监视器

###简介

用于监听WEB常见对象，HttpServletRequest，HeepSession，ServletContext的活动。

如：对象的创建和销毁，对象的属性变化，Session绑定JavaBean,对象的活化和钝化

###实现监听

1. 根据监听的不同的事件（创建和销毁，或者属性的变化）和不同监听对象源，实现对应的监听器对象

- 监听对象的创建和销毁

| 监听对象源         | 监听器对象             |
| ------------------ | ---------------------- |
| ServletContext     | ServletContextListener |
| HttpSession        | HttpSessionListener    |
| HttpServletRequest | ServletRequestListener |

- 监听对象的属性变化

| 监听对象源         | 监听器对象                      |
| ------------------ | ------------------------------- |
| ServletContext     | ServletContextAttributeListener |
| HttpSession        | HttpSessionAttributeListener    |
| HttpServletRequest | ServletRequestAttributeListener |

- Session绑定JavaBean

| 监听对象源  | 监听器对象                 |
| ----------- | -------------------------- |
| HttpSession | HttpSessionBindingListener |

实现监听器写在JavaBean类

- 对象的活化和钝化

对象的活化表示：对象实现了Serializable后，通过序列化将对象数据保存到磁盘中

对象的钝化表示：对象实现了Serializable后，通过反序列化将磁盘中的对象数据转化成实例化对象

**需要实现保存钝化的对象数据，需要指定保存位置**

在meta-inf目录下创建一个context.xml文件配置钝化时的存储的文件;

```
<Context>
 	<Manager className="org.apache.catalina.session.PersitentManager" maxIdleSwap="1">
 		<Store className="需要活化钝化的类Class" directory="钝化存储位置"/>
 	</Manager>
</Context>
```



| 监听对象源              | 监听器对象                    |
| ----------------------- | ----------------------------- |
| 实现了Se'rializable的类 | HttpSessionActivationListener |

实现监听器写在JavaBean类



2. 根据监听事件对象源的不同事件（创建或销毁）,处理不同业务逻辑

- 对象的创建和销毁

[^contextInitialized]: 监听对象创建
[^contextDestroyed]: 监听对象销毁

- 对象的属性变化

[^attributeAdded]: 添加了新属性
[^attributeRemoved]: 移除了属性
[^attributeReplaced]: 替换了属性

- Session绑定JavaBean

[^valueBound]: 绑定JavaBean
[^valueUnbound]: 解绑JavaBean

- 对象的活化钝化

[^sessionWillPassivate]: 对象活化
[^sessionDidActivate]: 对象钝化



3. 在web.xml中注册监听器

```
<listener>
       <listener-class>com.jr.exmaple.listener.attribute.MyServletContextAttributeListener
       </listener-class>
 </listener>
```

[^listener-class]: 监听器对象类路径

### 注意

- 监听**Session绑定JavaBean**的监听器对象和对象的**活化钝化**的监听器对象需要卸载实体类中
- 且这两种的监听器不需要在web.xml中注册





# 过滤器

### 简介

过滤器是执行过滤任务的对象，这些人物是针对对某一资源（servlet或静态内容）的请求或来自某一资源，进行响应执行，抑制执行。

例如：当用户进入某个页面时，可以通过过滤器进行拦截，然后验证判断该用户是否登陆过，如果登陆过才能继续访问该页面。否则重定向到登陆页面.

### 过滤器原理

![Filter过滤器描述](E:\笔记\JavaWeb\photo\Filter过滤器描述.bmp)

每次请求和响应都会经过过滤器，最后由过滤器将响应信息发送给客户端

### 生命周期

过滤器的生命周期和方法执行与Servlet很类似

1. [^void init(FilterConfig filterConfig)]: 将该过滤器的参数对象传递进来,类似Servlet中的init(ServletConfig servletConfig)将ServletConfig传递进来

   

2. [^void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)]: 当每次请求被过滤器请求的资源时，都会触发该方法，类似Servlet中的个Service(),实现该方法可以对请求资源进行请求拦截或放行

3. [^destroy]: 当服务器关闭时，销毁过滤器，释放资源

   

### 实现过滤

1. 创建一个类实现Filter接口
2. 重写接口中的方法doFilter()进行请求和响应的操作。
3. 在web.xml文件中配置

### FilterChain

FilterChain是Servlet容器为开发人员提供的对象，它提供了对某一个资源的已过滤请求调用链的视图。过滤器使用FilterChain调用链中的下一个过滤器。

如果调用的过滤器是链中的最后一个过滤器，则调用链中末尾的资源

如果多个Filter对同一个资源进行拦截就可以形成Filter链

且根据<filter-mapping>注册的顺序确定该过滤器在链中的前后位置

### FilterConfig

类似Servlet中的ServletConfig,在初始化过滤器时传入封装了初始化配置数据的对象

```
<filter>
        <filter-name>myfilter</filter-name>
        <filter-class>com.jr.exmaple.filter.MyFilter</filter-class>
        <init-param>
            <param-name>encode</param-name>
            <param-value>utf-8</param-value>
        </init-param>
</filter>
```

通过该对象可获得该Filter的参数数据(<init-param></init-param>)

### 过滤器的配置

- <url-pattern>

根据Servlet的虚拟路径，声明需要进行过滤的Servlet

1. 完全匹配：以“/目录名”开始，不含通配符（*），如：/servlet/demo。过滤制定虚拟目录的资源
2. 目录匹配：以“/开始”，“\*”结束，如：/servlet/\*。过滤该目录下的所有资源
3. 扩展名匹配：“*.xxx”，如：index.jsp。过滤所有jsp格式的资源

- <servlet-name>

根据注册Servlet时在<servlet-name>中声明的名字，确定需要过滤的Servlet资源

- <dispatcher>

当以什么方式去访问web资源时，才进行拦截操作

可取值有：REQUEST FORWARD ERROR INCLUDE

1. REQUEST(默认)：当是从浏览器直接访问资源，或者是重定向某个资源时进行拦截
2. FORWARD：如果该资源是请求转发过来的才会进行拦截
3. INCLUDE：如果目标资源是通过RequestDispatcher的include方法访问时，那么该过滤器才会拦截该资源
4. ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该资源将会被过滤器进行拦截。

### 过滤器的应用

- 验证过滤
- 日志记录和审计过滤
- 图像转换
- 数据压缩
- 加密
- 标记
- 触发资源访问事件
- 。。。





# 文件的上传与下载

