## 版本控制原理

- SVN 版本控制的实现就是，当数据的改变。比如新增了两条数据，那么就将这两条数据保存。并记录在该数据在哪里改变的。而不是每个版本都有一个副本，那么当改变该文件1000变是不是就有1000个副本了，这样子就会造成空间的浪费。
- Git 使用的时快照，扫描磁盘的结构进行对比

相比SVN，Git在速度上比SVN快很多。SVN在追溯代码的时候需要进行一个版本一个版本的跳跃，而git则是直接进行跳跃，速度很快。而且几乎都是在本地进行的

## SVN与Git的体验

> 集成版本控制：SVN

SVN的话它的版本控制实在服务端控制的。每次文件版本的合并和追溯，删除的操作最终的版本数据就是在服务端控制的.一旦服务器端被干掉的话，版本就不会控制了

与git相比，svn在文件权限控制上比git更占优势，毕竟git追求的是开源宗旨

> 分布式版本控制:Git

Git的话，它在本地客户端就有自己的版本控制。同时在服务端也用一套共用的版本控制。这样相比SVN的好处就是每次版本升级不用去请求服务端，在本地就能操作.
Git在创造之初看到了当时许多版本控制不能满足自己的需要。比如
1.速度
2.强大的分支管理
3.分布式
4.简单的界面操作
5.能够管理大型的项目（数据的存储量的速度）
这些也是Git相比其他版本控制的优点



## 参见SVN操作手段



一般SVN都是命令行操作
但可以加上一些插件，最后变成可是化操作：
服务端软件有:VisualSVN:SVN + Apache + Http
客户端软件有:TortoiseSVN

.svn文件夹是版本控制的文件数据，一般不要去改变它。同意Git也有.git文件



## Git的使用过程

1:从服务器上克隆数据库（包括代码和版本信息）到单机上
2.在自己的机器上创建分支，修改代码
3.在单机上自己创建的分支上提交代码
4.在单机上合并分支
5.新建一个分支，把服务器上的最新的代码fetch下来，然后跟自己的主分支合并
6.生成补丁（patch），把补丁发送给主开发者
7.看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。已解决，或者没有冲突，就通过。

8.一般开发者之间解决冲突的方法
：开发者之间可以使用pull命令解决冲突，解决完冲突之后在想主开发者提交补丁

主开发者的角度（假设主开发者不用开发代码）:我就是Goodle Source Code管理员
1.查看邮件或者通过其他方式查看一般开发者的提交状态
2.打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决）



## Git文件的四种生命周期

####untracked （红色）

不受版本控制

####unmodified（绿色）

正常情况下，与源代码数据一样，无改动

####modified  （黄色） 

更改了数据，但未提交数据

####staged    （蓝色）

提交了数据



## Git中有四种区域

####remoto reponsitory（远程仓库）

 最终文件合成地方

####local  reponsitory（本地仓库）

 本地合成文件区域

####stage  area  (临时区域)  

文件修改后未提交合成的临时区域

####workimg area （工作区域）

 文件数据修改区域

Git文件
.gitignore:将不受版本控制的文件放入里面。这样的话就版本提交的时候不提交该文件。在项目开发中，一些编译后产生的文件就不需要上传过去



## SVN关键字

####HEAD(head)

在版本控制就是最新版本的意思
####Checkout  

在项目第一次开始时用到的，就是从无开始获取完整的项目

####Checkin   

检入

####Export    

与Checkout类似的时都是下拉文件，但Checkout会受版本控制，export不受版本控制。

####Inport    

导入

####Edit      

 修改

####Commit    

 提交

####Updata    

更新

####Add       

新增目录或文件

####Delete   

删除目录或文件

####Clearup   

清理

####Lock      

锁定

####UnLock     

解锁



## Git命令

#### git 命令 -a 

显示该命令所有参数使用

#### mkdir(Linux)        

创建文件夹

mkdir 文件名

####echo (Linux)                           

创建文件并输入数据

echo 输入数据 >> 文件名.文件格式

#### help

查看帮助

> git help git指令:网页打开查看git指令帮助文档

####init

在本地当前文件夹下创建初始化和建立项目 ------git init   

####clone

在本地克隆远程项目                          

####status

查看本地仓库状态，如那些文件未加入，哪些未提交...

#### add                           

添加文件到临时区域

> git add    文件名.文件格式 

> git add .(添加所有)

####commit                           

提交文件到本地仓库

> git commit 文件名.文件格式 -m 备注信息：提交本地仓库加上备注
>

> git commit -a -m "备注"    //添加到临时区域并提交本地仓库加上备注
>

####diff -stage(默认diff) 

工作区域与临时与区域的代码比较，也可以进行主与分支进行比较 

> git diff 主名..分支名：查看两个分支的区别.**注意..**

####diff --cached

 本地仓库与临时与区域的代码比较

####log

查看修改日志

>  git log --oneline查看更多日志

####whatchanged 

同样都是查看日志，相比更加详细

####pull | pull -progress            

从远程仓库拉取文件到本地仓库，并合并当前本地仓库文件。加progress可以显示进度

####push 

从本地仓库上传文件到远程仓库，远程仓库的文件与本地上传的文件进行合并

> git push origin 分支名：上传到远程分支

####fetch

从远程仓库拉取文件到本地仓库，但并不合并当前本地仓库文件

####merge 

合并分支。如果本地分支fetch远程分支代码后。可以使用merge合并远程分支。与pull相比。pull就是直接一步拉取后就直接合并本地文件

> git merge 分支名：合并分支

##### 合并方式

**Fast-Forward**:理想状态合并。但不会记录合并信息。

**no-ff**：不进行Fast-Forward。所以合并信息会记录到版本控制

**Auto-merging**:自动合并

####patch 

上传本地仓库文件与远程仓库的补丁文件，但远程仓库的文件并未与之，而是合并发送给仓库管理员，待管理员审核后，管理员才将此补丁与之与远程仓库合并

####checkout 

 分支和主进行转换,也可以进行版本之间的切换

> git checkout -b dev origin/远程分支名:在本地创建新分支并切换新分支并关联远程分支
>

####tag:

版本所有文件打上标记，用于之后的版本与打上标记的版本进行切换

mv与git mv : mv是linux的命令。修改文件名的,修改工作区域的文件名。git mv也是修改文件名的。但就修改的stage area区域的文件名
rm与git rm : 同理。rm是Linuxmingl，用于移除本地文件。git rm也是移除文件，但移除的是临时区域文件。通过在 rm 携带参数 --cached :将临时区域文件移除，不影响本地区域。 --f:同时都移除文件

####revert 

取消某个版本的操作,比如在某个时间段提交了某个文件。那么就可以取消某个时间段的操作。并保存当前操作到日志里。   git revert + 版本号

####reset 

 与revert不同的是，revert取消某个时间段的某个操作。而reset是取消某个时间段之后的操作。不保存到日志里

> reset有三种格式：soft mixed hard (默认不加参数是mixed)

场景：
version 2 add 文件2
version 1 add 文件1

> soft:只是将文件2从临时区移除，并不影响文件2的数据

> mixed:是将文件2从临时去移除，并将它从本地仓库移除，但不影响文件2的数据（不会删除磁盘数据）。只是对它失去的了文本控制

> hard :是完全回退到version1的状态。本地数据也跟着改变。也就是文件2会被删除
>

####branch（分支） 

> git branch ：查看本地分支

> git branch -a：查看所有分支（本地与远程）

> git branch  分支名： 创建分支
>
> git branch -m 旧分支名 新分支名  ：分支重命名 
>
> git branch -d 分支名：删除分支 

####stash:

保存当前分支数据，但并不add到暂存区或提交到本地仓库。封装保存之后，即使以后在当前分支修改文件，也并不影响当前分支

####remote: 远程分支

> remote add origin + 远程链接 ：关联到远程分支

####Fork(GitHub)

如果你在github上看到别人比较优秀的项目，那么你就可以通过Fork将这个项目原封不动的复制到你自己的GitHub账号上

####PullRequest(GitHub)

如果你在Fork别人的项目之后，看到别人的项目代码有一个BUG，当你修改了这个代码之后。你就可以通过PullRequest，将修改的代码推送给项目管理员。

####remote

 将本地项目关联到远程。

> git remote add origin +远程项目链接 ：关联远程版本库
>
> git remote -v:查看关联远程项目版本
>
> git remote remove origin：删除关联远程

#### 注意

- Git命令前面都要加上git，与Linux命令进行区分
- pull和fetch的区别。两者都时进行数据的更新。但是pull除了拉去数据值外，还会与本地数据进行合并。

如果我只是想拉去远程数据，查看确认之后在进行合并本地的数据呢？

那么fetch就能实现。fetch只是拉去远程数据到本地，不会进行合并。在查看确认之后要想合并远程数据，可通过merge自行合并。

## 实战操作

### 将本地文件上传到GitHub上

1. 在本地初始化本地版本控制仓库

   cd 文件目录

   ```
   git init -- 初始化本地仓库
   ```

2. 添加到本地临时区域

   ```
   git add .  --‘.’：代表所有文件
   ```

3. 提交本地仓库

   ```
   git commit -m '提及备注信息'
   ```

4. 关联远程Github仓库

   ```
   git remote add origin 远程仓库连接
   ```

5. 提交到远程仓库

   ```
   git push -u origin master（分支名）
   ```

6. 如果是第一次上次，需要填写信息（github账号名和密码）

![上次到远程GitHub仓库](E:\笔记\版本控制\photo\上次到远程GitHub仓库.bmp)


